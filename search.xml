<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>POJ-1804</title>
    <url>/blog/POJ-1804/</url>
    <content><![CDATA[<p>求逆序对数</p>
<p>输入描述:</p>
<blockquote><p>The first line contains the number of scenarios.<br>For every scenario, you are given a line containing first the length N (1 &lt;= N &lt;= 1000) of the sequence,followed by the N elements of the sequence (each element is an integer in [-1000000, 1000000]). All numbers in this line are separated by single blanks.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>Start the output for every scenario with a line containing “Scenario #i:”, where i is the number of the scenario starting at 1. Then print a single line containing the minimal number of swaps of adjacent numbers that are necessary to sort the given sequence. Terminate the output for the scenario with a blank line.</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>4<br>4 2 8 0 3<br>10 0 1 2 3 4 5 6 7 8 9<br>6 -42 23 6 28 -100 65537<br>5 0 0 0 0 0</p>
</blockquote>

<p>输出</p>
<blockquote><p>Scenario #1:<br>3</p>
<p>Scenario #2:<br>0</p>
<p>Scenario #3:<br>5</p>
<p>Scenario #4:<br>0</p>
</blockquote>


<figure class="highlight c"><figcaption><span>POJ_1804_merge_sort.cpp</span><a href="/downloads/code/POJ_1804_merge_sort.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = merge_sort(L, mid) + merge_sort(mid+<span class="number">1</span>, R);</span><br><span class="line">    <span class="keyword">int</span> l = L, r=mid+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid &amp;&amp; r&lt;=R){</span><br><span class="line">        <span class="keyword">if</span>(a[l]&lt;=a[r]) tmp[k++] = a[l++];</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            tmp[k++] = a[r++];</span><br><span class="line">            res += mid-l+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=mid) tmp[k++] = a[l++];</span><br><span class="line">    <span class="keyword">while</span>(r&lt;=R) tmp[k++] = a[r++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=L, j=<span class="number">0</span>; i&lt;=R; i++, j++) a[i] = tmp[j];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++){</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> res = merge_sort(<span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>, i, res);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>POJ_1804_seg_tree.cpp</span><a href="/downloads/code/POJ_1804_seg_tree.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], bin[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    sum[x] = sum[x*<span class="number">2</span>] + sum[x*<span class="number">2</span>+<span class="number">1</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(l==r){</span><br><span class="line">        sum[x] = <span class="number">0</span>; <span class="comment">//mistake</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l, mid, x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>, r, x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    update(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(A&lt;=l &amp;&amp; B&gt;=r) <span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(A&lt;=mid) ans += query(A, B, l, mid, x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(B&gt;mid) ans += query(A, B, mid+<span class="number">1</span>, r, x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(l==r) {</span><br><span class="line">        sum[x]+= v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt;=mid) change(pos, v, l, mid, x&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> change(pos, v, mid+<span class="number">1</span>, r, x&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    update(x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=T;i++){</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="built_in">memset</span>(bin, <span class="number">0</span>, <span class="keyword">sizeof</span> bin);</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">            bin[++cnt] = a[i];</span><br><span class="line">        }</span><br><span class="line">        sort(bin+<span class="number">1</span>, bin+<span class="number">1</span>+cnt);</span><br><span class="line">        cnt = unique(bin+<span class="number">1</span>, bin+<span class="number">1</span>+cnt) - bin<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">            a[i] = lower_bound(bin + <span class="number">1</span>, bin + <span class="number">1</span> + cnt, a[i]) - bin;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        build(<span class="number">1</span>, cnt, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            res += query(a[i]+<span class="number">1</span>, cnt, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">            change(a[i], <span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n%d\n\n"</span>, i, res);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wanmen</category>
      </categories>
      <tags>
        <tag>seg_tree</tag>
        <tag>merge_sort</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ_3067</title>
    <url>/blog/POJ-3067/</url>
    <content><![CDATA[<p>Japan plans to welcome the ACM ICPC World Finals and a lot of roads must be built for the venue. Japan is tall island with N cities on the East coast and M cities on the West coast (M &lt;= 1000, N &lt;= 1000). K superhighways will be build. Cities on each coast are numbered 1, 2, … from North to South. Each superhighway is straight line and connects city on the East coast with city of the West coast. The funding for the construction is guaranteed by ACM. A major portion of the sum is determined by the number of crossings between superhighways. At most two superhighways cross at one location. Write a program that calculates the number of the crossings between superhighways.</p>
<p>输入描述:</p>
<blockquote><p>The input file starts with T - the number of test cases. Each test case starts with three numbers – N, M, K. Each of the next K lines contains two numbers – the numbers of cities connected by the superhighway. The first one is the number of the city on the East coast and second one is the number of the city of the West coast.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>For each test case write one line on the standard output:<br>Test case (case number): (number of crossings)</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>1<br>3 4 4<br>1 4<br>2 3<br>3 2<br>3 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>Test case 1: 5</p>
</blockquote>


<figure class="highlight c"><figcaption><span>POJ_3067.cpp</span><a href="/downloads/code/POJ_3067.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> a, b, n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll c[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp; p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;p2)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(p1.second != p2.second) <span class="keyword">return</span> p1.second&gt;p2.second;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p1.first&lt; p2.first;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=N;i+=lowbit(i))</span><br><span class="line">        c[i] += <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))</span><br><span class="line">        ans += c[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=T;t++){</span><br><span class="line">        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;n);</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x, &amp;y);</span><br><span class="line">            p.push_back({x, y});</span><br><span class="line">        }</span><br><span class="line">        sort(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();i++) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span> ,p[i].first, p[i].second);</span><br><span class="line">        ll ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.<span class="built_in">size</span>();i++){</span><br><span class="line">            x = p[i].first, y = p[i].second;</span><br><span class="line">            ans += query(x<span class="number">-1</span>);</span><br><span class="line">            add(x);</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Test case %d: %lld\n"</span>, t,ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wanmen</category>
      </categories>
      <tags>
        <tag>bit_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU_2852</title>
    <url>/blog/HDU-2852/</url>
    <content><![CDATA[<p>For the k-th number, we all should be very familiar with it. Of course,to kiki it is also simple. Now Kiki meets a very similar problem, kiki wants to design a container, the container is to support the three operations.</p>
<p>Push: Push a given element e to container</p>
<p>Pop: Pop element of a given e from container</p>
<p>Query: Given two elements a and k, query the kth larger number which greater than a in container;</p>
<p>Although Kiki is very intelligent, she can not think of how to do it, can you help her to solve this problem?</p>
<p>输入描述:</p>
<blockquote><p>Input some groups of test data ,each test data the first number is an integer m (1 &lt;= m &lt;100000), means that the number of operation to do. The next m lines, each line will be an integer p at the beginning, p which has three values:<br>If p is 0, then there will be an integer e (0 &lt;e &lt;100000), means press element e into Container.</p>
<p>If p is 1, then there will be an integer e (0 &lt;e &lt;100000), indicated that delete the element e from the container</p>
<p>If p is 2, then there will be two integers a and k (0 &lt;a &lt;100000, 0 &lt;k &lt;10000),means the inquiries, the element is greater than a, and the k-th larger number.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>For each deletion, if you want to delete the element which does not exist, the output “No Elment!”. For each query, output the suitable answers in line .if the number does not exist, the output “Not Find!”.</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5<br>0 5<br>1 2<br>0 6<br>2 3 2<br>2 8 1<br>7<br>0 2<br>0 2<br>0 4<br>2 1 1<br>2 1 2<br>2 1 3<br>2 1 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>No Elment!<br>6<br>Not Find!<br>2<br>2<br>4<br>Not Find!</p>
</blockquote>


<figure class="highlight c"><figcaption><span>HDU_2852.cpp</span><a href="/downloads/code/HDU_2852.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[N+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x &amp;-x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=N;i+=lowbit(i))</span><br><span class="line">        sum[i] +=d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">        ans += sum[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> m, t, e, a, k;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m)){</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="keyword">while</span>(m--){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">0</span>){</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e);</span><br><span class="line">                add(e, <span class="number">1</span>);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">1</span>){</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;e);</span><br><span class="line">                <span class="keyword">if</span>(!(query(e) - query(e<span class="number">-1</span>))) <span class="built_in">printf</span>(<span class="string">"No Elment!\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> add(e, <span class="number">-1</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;k);</span><br><span class="line">                <span class="keyword">int</span> v = query(a)+ k;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = N;</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r){</span><br><span class="line">                    <span class="keyword">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(query(mid)&gt;=v) r = mid;</span><br><span class="line">                    <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(r==<span class="number">0</span> || r==N) <span class="built_in">printf</span>(<span class="string">"Not Find!\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wanmen</category>
      </categories>
      <tags>
        <tag>bit_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>poj_2352</title>
    <url>/blog/poj-2352/</url>
    <content><![CDATA[<p>Astronomers often examine star maps where stars are represented by points on a plane and each star has Cartesian coordinates. Let the level of a star be an amount of the stars that are not higher and not to the right of the given star. Astronomers want to know the distribution of the levels of the stars.</p>
<img src="/downloads/imgs/poj-2352.png" class="example" title="title exg" alt="alt exg">

<p>For example, look at the map shown on the figure above. Level of the star number 5 is equal to 3 (it’s formed by three stars with a numbers 1, 2 and 4). And the levels of the stars numbered by 2 and 4 are 1. At this map there are only one star of the level 0, two stars of the level 1, one star of the level 2, and one star of the level 3.</p>
<p>You are to write a program that will count the amounts of the stars of each level on a given map.</p>
<p>输入描述:</p>
<blockquote><p>The first line of the input file contains a number of stars N (1&lt;=N&lt;=15000). The following N lines describe coordinates of stars (two integers X and Y per line separated by a space, 0&lt;=X,Y&lt;=32000). There can be only one star at one point of the plane. Stars are listed in ascending order of Y coordinate. Stars with equal Y coordinates are listed in ascending order of X coordinate.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>The output should contain N lines, one number per line. The first line contains amount of stars of the level 0, the second does amount of stars of the level 1 and so on, the last line contains amount of stars of the level N-1.</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5<br>1 1<br>5 1<br>7 1<br>3 3<br>5 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>2<br>1<br>1<br>0</p>
</blockquote>



<figure class="highlight c"><figcaption><span>poj_2352.cpp</span><a href="/downloads/code/poj_2352.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">15010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; coords;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;p2)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(p1.second!=p2.second){</span><br><span class="line">        <span class="keyword">return</span> p1.second&lt;p2.second;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">return</span> p1.first&lt;p2.first;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">32001</span>;</span><br><span class="line"><span class="keyword">int</span> c[M+<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;=M;i+=lowbit(i)){</span><br><span class="line">        c[i] += d;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i)){</span><br><span class="line">        ans += c[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        coords.push_back(make_pair(x, y));</span><br><span class="line">    }</span><br><span class="line">    sort(coords.<span class="built_in">begin</span>(), coords.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;coords.<span class="built_in">size</span>();i++){</span><br><span class="line">        add(coords[i].first, <span class="number">1</span>);</span><br><span class="line">        ans[query(coords[i].first)] ++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wanmen</category>
      </categories>
      <tags>
        <tag>bit_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ_3468</title>
    <url>/blog/POJ-3468/</url>
    <content><![CDATA[<p>You have N integers, A1, A2, … , AN. You need to deal with two kinds of operations. One type of operation is to add some given number to each number in a given interval. The other is to ask for the sum of numbers in a given interval.</p>
<p>Input</p>
<p>输入描述:</p>
<blockquote><p>The first line contains two numbers N and Q. 1 ≤ N,Q ≤ 100000.<br>The second line contains N numbers, the initial values of A1, A2, … , AN. -1000000000 ≤ Ai ≤ 1000000000.<br>Each of the next Q lines represents an operation.<br>“C a b c” means adding c to each of Aa, Aa+1, … , Ab. -10000 ≤ c ≤ 10000.<br>“Q a b” means querying the sum of Aa, Aa+1, … , Ab.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>You need to answer all Q commands in order. One answer in a line.</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>10 5<br>1 2 3 4 5 6 7 8 9 10<br>Q 4 4<br>Q 1 10<br>Q 2 4<br>C 3 6 3<br>Q 2 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>4<br>55<br>9<br>15</p>
</blockquote>

<p>说明</p>
<blockquote><p>The sums may exceed the range of 32-bit integers</p>
</blockquote>


<figure class="highlight c"><figcaption><span>poj_3468.cpp</span><a href="/downloads/code/poj_3468.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll N,tree1[<span class="number">100001</span>],tree2[<span class="number">100001</span>];</span><br><span class="line">ll a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (x&amp;(-x));</span><br><span class="line">}</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(ll x ,ll val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll i;</span><br><span class="line">    <span class="keyword">for</span>( i = x ; i &lt;= N;i+=lowbit(i) )</span><br><span class="line">    {</span><br><span class="line">        tree1[i]+=val;</span><br><span class="line">        tree2[i]+=x*val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll i;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i = x ; i &gt; <span class="number">0</span> ;i-=lowbit(i))</span><br><span class="line">    {</span><br><span class="line">        sum+=(x+<span class="number">1</span>)*tree1[i]-tree2[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ll  Q , i , A ,B , C;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; Q;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ;i &lt;= N ; i++)</span><br><span class="line">    {</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">         update(i ,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span> ; i &lt;= Q ; i ++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'Q'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; query (B)- query(A<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; C;</span><br><span class="line">            update(A , C);</span><br><span class="line">            update(B+<span class="number">1</span> ,-C );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wanmen</category>
      </categories>
      <tags>
        <tag>bit_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ_2155_matrix</title>
    <url>/blog/POJ-2155-matrix/</url>
    <content><![CDATA[<p>Language:<br>Matrix<br>Time Limit: 3000MS        Memory Limit: 65536K<br>Total Submissions: 37057        Accepted: 13286<br>Description</p>
<p>Given an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N).</p>
<p>We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions.</p>
<ol>
<li>C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2).</li>
<li>Q x y (1 &lt;= x, y &lt;= n) querys A[x, y].</li>
</ol>
<p>输入描述:</p>
<blockquote><p>The first line of the input is an integer X (X &lt;= 10) representing the number of test cases. The following X blocks each represents a test case.</p>
<p>The first line of each block contains two numbers N and T (2 &lt;= N &lt;= 1000, 1 &lt;= T &lt;= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format “Q x y” or “C x1 y1 x2 y2”, which has been described above.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>For each querying output one line, which has an integer representing A[x, y].</p>
<p>There is a blank line between every two continuous test cases.</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>1<br>2 10<br>C 2 1 2 2<br>Q 2 2<br>C 2 1 2 1<br>Q 1 1<br>C 1 1 2 1<br>C 1 2 1 2<br>C 1 1 2 2<br>Q 1 1<br>C 1 1 2 1<br>Q 2 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>0<br>0<br>1</p>
</blockquote>


<figure class="highlight c"><figcaption><span>poj_2155.cpp</span><a href="/downloads/code/poj_2155.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> sum[N][N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">int</span> ty = y;</span><br><span class="line">        <span class="keyword">while</span>(ty&gt;<span class="number">0</span>){</span><br><span class="line">            ans += sum[x][ty];</span><br><span class="line">            ty -= C(ty);</span><br><span class="line">        }</span><br><span class="line">        x -= C(x);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n){</span><br><span class="line">        <span class="keyword">int</span> ty = y;</span><br><span class="line">        <span class="keyword">while</span>(ty&lt;=n){</span><br><span class="line">            sum[x][ty] = (sum[x][ty] + d) % <span class="number">2</span>;</span><br><span class="line">            ty += C(ty);</span><br><span class="line">        }</span><br><span class="line">        x += C(x);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> X ;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X);</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;X;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;T);</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="keyword">while</span>(T--){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);</span><br><span class="line">            <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="string">'C'</span>){</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line"><span class="comment">//                printf("%d %d %d %d\n", x1,y1, x2,y2);</span></span><br><span class="line">                add(x1, y1, <span class="number">1</span>);</span><br><span class="line">                add(x1, y2+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>, y1, <span class="number">1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>, y2+<span class="number">1</span>, +<span class="number">1</span>);</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="string">'Q'</span>){</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="comment">//                printf("%d %d\n", x, y);</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(x, y) % <span class="number">2</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>wanmen</category>
      </categories>
      <tags>
        <tag>bit_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Planning for Autononous Cars that Leverage Effects on Human Actions</title>
    <url>/blog/Planning-for-Autononous-Cars/</url>
    <content><![CDATA[<p><b>Idea: </b></p>
<ol>
<li>Action from the autonomous car will affect human responses and these could be leveraged for planning.</li>
<li>Approximate human as optimal driver, with a reward function acquired through inverse reinforcement learning.</li>
</ol>
<p><b>Motivation:</b></p>
<ol>
<li>Current autonomous cars are defensive</li>
<li>Plan more efficient and communicative behaviors for autonomous cars.</li>
</ol>
<a id="more"></a>

<p><b>Assumptions</b></p>
<ol>
<li>Two car system.</li>
</ol>
<p><b>Method</b></p>
<ol>
<li><p>The robot will use MPC at every iteration by computing a finite sequence of actions to maximize its reward and then execute the first one. (Eqn 5).</p>
<img src="/downloads/imgs/auton1.png" class="example" title="title exg" alt="alt exg">
</li>
<li><p>Compute u^{*}_H by optimizing the following:</p>
<img src="/downloads/imgs/auton2.png" class="example" title="title exg" alt="alt exg">
</li>
<li><p>Learn r_h with inverse reinforcement learning (separate optimization process that maximizes probability of demonstrations).</p>
</li>
</ol>
<p><b>Implementations</b><br>Use theano to compute jacobian and hessian symbolically and use L-BFGS to optimize Eqn 5. (code: <a href="https://github.com/dsadigh/driving-interactions/blob/master/utils.py" target="_blank" rel="noopener">https://github.com/dsadigh/driving-interactions/blob/master/utils.py</a>)</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>HRI</tag>
      </tags>
  </entry>
  <entry>
    <title>Human-Robot-Mutual</title>
    <url>/blog/Human-Robot-Mutual/</url>
    <content><![CDATA[<blockquote><p>Formalizing Human-Robot Mutual Adaptation: A Bounded Memory Model</p>
</blockquote>

<p><b>Idea: </b> the robot reasons how human may change its strategy, based on a model of human adaptation.<br><b>Motivation:</b></p>
<ol>
<li>Previous works do not use a model of human adaptation that can enable the robot to actively influence the actions of human.</li>
<li>Previous works do not reason over the human adaptation throughout the interaction. Compare with Intention-Aware Motion Planning paper.</li>
</ol>
<a id="more"></a>

<p><b>Assumptions</b></p>
<ol>
<li>Definition of m_r, m_h requires a specific collaborative task (rotating table as in paper).</li>
</ol>
<p><b>Preliminaries</b></p>
<ol>
<li>f maps QxArxAh into modes M: {0,1}.</li>
<li>Q=X_state x H_k at time step i is reprensented eventually as m_{h}^{i}, m_{r}^{i}, computed over a history of length k.</li>
</ol>
<p><b>Method</b><br>Modelling (adaptable human): Human adaptability a is accounted for via transition function P: Q to P(Q). At state q, the human will choose action specified by m_r with probability a, or m_h with 1-a.<br>Planning (adaptable robot):</p>
<ol>
<li>S: X x Y; X: X_world x M^{k} x M^{k}. M is the mode of robot/human; Y is partial observable variable, adaptabiity.</li>
<li>human policy $\pi_h$ is from BAM model. It outputs m_h or m_r.</li>
<li>The belief is based on unobserable variable a. Therefore, MOMDP maps from V(Q, b(a)) to a_r. Then BAM models gives human action a_h. Then use Eqn.3 (below) to update the belief.</li>
</ol>
<img src="/downloads/imgs/mutual1.png" class="example" title="title exg" alt="alt exg">]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>HRI</tag>
      </tags>
  </entry>
  <entry>
    <title>Intention-Aware Motion Planning</title>
    <url>/blog/CSCI699/</url>
    <content><![CDATA[<blockquote><p>Intention-aware motion planning</p>
</blockquote>

<p><b>Motivation:</b> Motion planning with uncertainty in human intention.<br><b>Assumptions</b></p>
<ol>
<li>A finite set of unknown intentions.</li>
<li>Given intention, the agent’s dynamics is modeled and known to robot.</li>
<li>The agent has perfect information on the robot’s and its own state.</li>
</ol>
<a id="more"></a>

<p><b>Idea:</b></p>
<ol>
<li>Model intent-aware motion planning as a Partially Observable Markov Decision Process.</li>
<li>The agent’s intention is the primary uncertainty state variable in MOMDP.</li>
</ol>
<p><b>Preliminaries</b></p>
<ol>
<li>MDP allows to model action uncertainty only and the state is fully obserable.</li>
<li>POMDP specifies p(o|s’,a), which models observation uncertainty.</li>
<li>In POMDP, state is not known and is represented as a belief b(s).</li>
<li>A POMDP policy induces a value function mapping from b to reward.</li>
<li>Each alpha-vector defines a hyperplane over B. The value function V can be represented as a finite set of hyperplanes.</li>
</ol>
<p><b>Method</b></p>
<ol>
<li>In the offline stage, construct a motion model for each agent intention; in the online stage, infer over a finite set of agent intentions and act accordingly.</li>
<li>Modelling<ol>
<li>Each intention type corresponds to an agent policy $\rou: XxYx\theta$.</li>
<li>$\rou$ can be computed by solving a simplified MDP. Assume the pedestrian follows shortest path and avoids collision.</li>
</ol>
</li>
<li>Execution<ol>
<li>MOMDP policy, represented as a value function $V(x, y, b_\theta)$.</li>
<li>First selects an action for current belief: $V(x, y, b_\theta) = max_{a} {a * b_\theta}$</li>
<li>Then update the belief: $b’<em>\theta = Z(x’,y’, o) \sum</em>{\theta}{T_x(x, a, x’) * T_y{x, y, \theta, y’} * b(\theta)}$</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>HRI</tag>
      </tags>
  </entry>
  <entry>
    <title>reinforcement_learning-1</title>
    <url>/blog/reinforcement-learning1/</url>
    <content><![CDATA[<blockquote><p>End-to-End Robotic Reinforcement Learning without Reward Engineering</p>
</blockquote>

<p><b>Motivation:</b> Manual-engineered reward defeats the purpose of end-to-end learning<br><b>Idea:</b></p>
<ol>
<li>Human periodically labels the queries, used to supervise reward training</li>
<li>Train a classifier to predict reward, based on high-dimensional input (pixels)</li>
<li>Use RL to provide negative samples for step2 and RL uses the reward from step 2.</li>
</ol>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>HRI</tag>
        <tag>reinforcement_learning</tag>
      </tags>
  </entry>
  <entry>
    <title>metric_learning-1</title>
    <url>/blog/metric-learning/</url>
    <content><![CDATA[<blockquote><p>Self-training with Noisy Student improves ImageNet classification</p>
</blockquote>

<p>The idea is to train a noisy student no smaller than the teacher and repeat.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">While not converge</span><br><span class="line">    1. Train a teacher net to provide pseudo-labels (unoised).</span><br><span class="line">    2. Train a larger student model with pseudo and groundtruth labels (noised).</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<blockquote><p>Embedding Expansion: Augmentation in Embedding Space for Deep Metric Learning</p>
</blockquote>
<p><b>Idea:</b> Proposes an embedding augmentation and combines with representation learning.<br><b>Motivation:</b> To generate hard-synthsis with easy samples without using GAN.<br><b>Related Work:</b> query expansion and database augmentation.<br><b>Method:</b> Loss/Negative Pair Mining</p>
<blockquote><p>Momentum Contrast for Unsupervised Visual Representation Learning</p>
</blockquote>
<p><b>Motivation:</b> Close the gap between unsupervised learning and supervised learning.<br><b>Idea: </b>Reformulate contrastive matching as dictionary look-up<br><b>Method</b></p>
<ol>
<li>Loss function: maximize softmax on the positive key</li>
<li>Implement the dictionary as a queue and maintains a momentum update on the key encoder</li>
</ol>
<blockquote><p>A Simple Framework for Contrastive Learning of Visual Representations</p>
</blockquote>
<p><b>Method</b></p>
<ol>
<li>Data augmentation plays a crucial role</li>
<li>Nonlinear transformation between representation and loss is crucial</li>
<li>Larger batch_size and more training steps compared to supervised training</li>
</ol>
<blockquote><p>Learning Diverse Fashion Collocation by Neural Graph Filtering</p>
</blockquote>
<p><b>Motivation:</b> To achieve compatibility, diversity and flexibility requirements of fashion<br>collocation.</p>
<p><b>Highlights:</b><br>    1. Edge-centric graph operations with permutation-invariant symmetric aggregation function<br>    2. Use focal loss to handle imbalance.<br>    3. New dataset for style classification.</p>
]]></content>
      <categories>
        <category>Papers</category>
      </categories>
      <tags>
        <tag>metric-learning</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理</title>
    <url>/blog/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>《孙子算经》中的题目：有物不知其数，A[i]个一数余B[i]，问该物总数几何？</p>
<p>输入描述:</p>
<blockquote><p>第一行，一个整数n。<br>接下来n行，每行两个整数A[i]和B[i],表示用这个数模A[i]得B[i]。<br>保证所有A[i]两两互素。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出最小的满足条件的正整数解。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>3<br>2 1<br>3 2<br>5 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>23</p>
</blockquote>


<figure class="highlight c"><figcaption><span>shengyudingli.cpp</span><a href="/downloads/code/shengyudingli.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> A[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, LL &amp;x, LL &amp;y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>){</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(b, a%b, x, y);</span><br><span class="line">    LL x1 = y;</span><br><span class="line">    LL y1 = x - a/b * y;</span><br><span class="line">    x = x1, y= y1;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    LL mul = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A[i], &amp;B[i]);</span><br><span class="line">        mul *= A[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        LL Mi = mul / A[i];</span><br><span class="line">        LL x, y;</span><br><span class="line">        exgcd(Mi, A[i], x, y);</span><br><span class="line">        sum += ((x%A[i] + A[i]) % A[i]) * Mi * B[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, sum % mul);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>青蛙的约会</title>
    <url>/blog/%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/</url>
    <content><![CDATA[<p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。<br>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。</p>
<p>输入描述:</p>
<blockquote><p>输入只包括一行5个整数x，y，m，n，L</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>1 2 3 4 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>4</p>
</blockquote>


<figure class="highlight c"><figcaption><span>qingwadeyuehui.cpp</span><a href="/downloads/code/qingwadeyuehui.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">int</span> s1, s2, m, n, L;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>){</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span>  res = exgcd(b, a%b, x, y);</span><br><span class="line">    <span class="keyword">int</span> x1 = y;</span><br><span class="line">    <span class="keyword">int</span> y1 =  x - a/b * y;</span><br><span class="line">    x = x1, y = y1;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;s1, &amp;s2, &amp;m, &amp;n, &amp;L);</span><br><span class="line">    s1%=L, s2%=L;</span><br><span class="line">    <span class="keyword">int</span> a = m-n, b = s2-s1;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">0</span>) a = -a, b = -b;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> d = exgcd(a, L, x, y);</span><br><span class="line">    <span class="keyword">if</span>(b%d) <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">    <span class="keyword">else</span> x = x * b / d,  L/= d, <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (x%L + L) % L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>组合计数</title>
    <url>/blog/%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>求组合数，C(n, m)% P。</p>
<p>输入描述:</p>
<blockquote><p>两个整数n和m</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>C(n,m) 表示的结果</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>20</p>
</blockquote>


<figure class="highlight c"><figcaption><span>zuheshu1.cpp</span><a href="/downloads/code/zuheshu1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[N+<span class="number">10</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[N+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++){</span><br><span class="line">        <span class="keyword">if</span>(son[i].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j+=i) {</span><br><span class="line">                son[j].push_back(i); <span class="comment">//该数是质数， 包含该质数因子本身</span></span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;son[i].<span class="built_in">size</span>();j++){</span><br><span class="line">            <span class="keyword">int</span> x = son[i][j], c = <span class="number">0</span>, p=i;</span><br><span class="line">            <span class="keyword">while</span>(p%x==<span class="number">0</span>){</span><br><span class="line">                p/=x, c++;</span><br><span class="line">            }</span><br><span class="line">            cnt[x] += c*k;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fast</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b){</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res * a % P;</span><br><span class="line">        a = a * a % P;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    prime();</span><br><span class="line">    solve(n, <span class="number">1</span>);</span><br><span class="line">    solve(n-m, <span class="number">-1</span>);</span><br><span class="line">    solve(m, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&gt;<span class="number">0</span>)</span><br><span class="line">            res = res * fast(i, cnt[i]) % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuheshu2.cpp</span><a href="/downloads/code/zuheshu2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>, P = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pcnt, pr[N+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> mark[N+<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">if</span>(!mark[i]) {</span><br><span class="line">            pr[++pcnt] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">                mark[j] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//阶乘质因子分解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=pcnt &amp;&amp; pr[i]&lt;=n;i++){  <span class="comment">//starts from 1</span></span><br><span class="line">        <span class="keyword">int</span> x = pr[i];</span><br><span class="line">        <span class="comment">// x在n!中指数</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = x;</span><br><span class="line">        <span class="keyword">while</span>(t&lt;=n){</span><br><span class="line">            cnt[x] += n/t * k;</span><br><span class="line">            t*=x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fast</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x){</span><br><span class="line">        <span class="keyword">if</span>(x&amp;<span class="number">1</span>) res = res * n % P;</span><br><span class="line">        n = n * n % P;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    prime();</span><br><span class="line">    solve(n, <span class="number">1</span>);</span><br><span class="line">    solve(n-m, <span class="number">-1</span>);</span><br><span class="line">    solve(m, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i])</span><br><span class="line">            res = res * fast(i, cnt[i]) % P;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuheshu3.cpp</span><a href="/downloads/code/zuheshu3.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">ll T,f[<span class="number">1000009</span>],n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">fast</span><span class="params">(ll x,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)res=res*x%p,res%=p;</span><br><span class="line">        x=x*x%p,x%=p;</span><br><span class="line">        b/=<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1000000</span>;i++)f[i]=(f[i<span class="number">-1</span>]%p*i)%p;</span><br><span class="line">    <span class="keyword">char</span> in[<span class="number">20</span>]={<span class="string">"data0.in"</span>};</span><br><span class="line">    <span class="keyword">char</span> out[<span class="number">20</span>]={<span class="string">"data0.out"</span>};</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> cas=<span class="number">1</span>;cas&lt;=<span class="number">10</span>;cas++){</span><br><span class="line">        freopen(in,<span class="string">"r"</span>,<span class="built_in">stdin</span>);in[<span class="number">4</span>]++;</span><br><span class="line">        freopen(out,<span class="string">"w"</span>,<span class="built_in">stdout</span>);out[<span class="number">4</span>]++;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="comment">//cerr&lt;&lt;n&lt;&lt;" "&lt;&lt;m&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// 除法转为逆元+费马小定理</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,f[n]%p*fast(f[m],p<span class="number">-2</span>)%p*fast(f[n-m],p<span class="number">-2</span>)%p);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>区间素数</title>
    <url>/blog/%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B02/</url>
    <content><![CDATA[<p>给你两个整数a,b，求[a,b]区间内素数的个数</p>
<p>输入描述:</p>
<blockquote><p>输入一行包含两个正整数a,b。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出一个整数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>350874129179 350875129179</p>
</blockquote>

<p>输出</p>
<blockquote><p>37682</p>
</blockquote>


<figure class="highlight c"><figcaption><span>qujiansushu.cpp</span><a href="/downloads/code/qujiansushu.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> mark[N+<span class="number">10</span>], pmark[N+<span class="number">10</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL a, b;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prime</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">sqrt</span>(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!mark[i]){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+i;j&lt;=n;j+=i)</span><br><span class="line">                mark[j] = <span class="number">1</span>;</span><br><span class="line">            LL p;</span><br><span class="line">            <span class="keyword">if</span>(a%i==<span class="number">0</span>) p = a;</span><br><span class="line">            <span class="keyword">else</span> p = <span class="built_in">max</span>(<span class="number">2L</span>L, (a/i + <span class="number">1</span>) * i);</span><br><span class="line">            <span class="keyword">for</span>(; p&lt;=b; p+=i) pmark[p-a] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line">    prime();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=b-a;i++)</span><br><span class="line">        <span class="keyword">if</span>(pmark[i]==<span class="number">0</span>) sum++;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>) sum--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>区间因子</title>
    <url>/blog/%E5%8C%BA%E9%97%B4%E7%B4%A0%E6%95%B0%E5%92%8C/</url>
    <content><![CDATA[<p>给定n个询问，需要输出[L,R]范围内每个数的因子个数之和。</p>
<p>输入描述:</p>
<blockquote><p>第一行一个整数n,表示询问数量。<br>接下来n行，每行两个整数L和R。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问，输出相应的结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>2<br>10 55<br>33 101</p>
</blockquote>

<p>输出</p>
<blockquote><p>208<br>365</p>
</blockquote>




]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包</title>
    <url>/blog/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>有一个体积为V的背包，有m种物品，每种物品有体积和价值，且数量一定。求背包能装下的最大价值。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数V和m。<br>接下来m行，每行3个整数，表示第i种物品的数量、体积和价值。<br>V&lt;=10^4, m&lt;=500，个数、体积、价值不超过1000。</p>
<p>输出描述:</p>
<blockquote><p>输出一个整数，表示背包能装下的最大价值。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>10 4<br>2 3 2<br>2 4 3<br>1 2 2<br>4 5 3</p>
</blockquote>

<p>输出<br>8</p></blockquote>


<figure class="highlight c"><figcaption><span>duochongbeibao1.cpp</span><a href="/downloads/code/duochongbeibao1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> m, V;</span><br><span class="line"><span class="keyword">int</span> dp[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;V, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=<span class="number">0</span>;j--){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=x;k++)</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=k*y)</span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j], dp[j-k*y] + k*z);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>duochongbeibao2.cpp</span><a href="/downloads/code/duochongbeibao2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> m, V;</span><br><span class="line"><span class="keyword">int</span> dp[M];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;V, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=x; j*=<span class="number">2</span>){</span><br><span class="line">            A[k++] = j;</span><br><span class="line">            x-=j;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(x) A[k++] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// note: m must be at the outerloop</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;k;m++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=V;j&gt;=A[m]*y; j--){</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j], dp[j-A[m]*y] + A[m]*z);</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>duochongbeibao3.cpp</span><a href="/downloads/code/duochongbeibao3.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// dp[k*y+j] = max(dp[t*y+j] + (k-t)*z)</span></span><br><span class="line"><span class="comment">// dp[k*y+j] = max(dp[t*y+j] - t*z) + k*z</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> m, V;</span><br><span class="line"><span class="keyword">int</span> dp[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> cnt, val;</span><br><span class="line">}Q[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;V, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;y;j++) {</span><br><span class="line">            <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k * y + j &lt;= V; k++) {</span><br><span class="line">                node tmp = (node){k, dp[k*y+j] - k*z}; <span class="comment">//easy to forget</span></span><br><span class="line">                <span class="keyword">while</span>(L&lt;=R &amp;&amp; Q[R].val&lt;=tmp.val) R--;</span><br><span class="line">                <span class="keyword">while</span>(L&lt;=R &amp;&amp; tmp.cnt - Q[L].cnt &gt; x ) L++;</span><br><span class="line">                Q[++R] = tmp;</span><br><span class="line">                dp[k*y+j] = <span class="built_in">max</span>(dp[k*y+j], Q[L].val + k*z);</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[V]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>monotone_queue</tag>
        <tag>optimization</tag>
      </tags>
  </entry>
  <entry>
    <title>骑士</title>
    <url>/blog/%E9%AA%91%E5%A3%AB/</url>
    <content><![CDATA[<p>在一个5×5的棋盘上有12个白色的骑士和12个黑色的骑士， 且有一个空位。在任何时候一个骑士都能按照骑<br>士的走法（它可以走到和它横坐标相差为1，纵坐标相差为2或者横坐标相差为2，纵坐标相差为1的格子）移动到空<br>位上。 给定一个初始的棋盘，怎样才能经过移动变成如下目标棋盘： 为了体现出骑士精神，他们必须以最少的步<br>数完成任务。</p>
<p>输入描述:</p>
<blockquote><p>第一行有一个正整数T()，表示一共有N组数据。接下来有T个5×5的矩阵，0表示白色骑士，1表示黑色骑<br>士，*表示空位。两组数据之间没有空行。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每组数据都输出一行。如果能在15步以内（包括15步）到达目标状态，则输出步数，否则输出－1。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>2<br>10110<br>01<em>11<br>10111<br>01001<br>00000<br>01011<br>110</em>1<br>01110<br>01010<br>00100</p>
</blockquote>

<p>输出</p>
<blockquote><p>7<br>-1</p>
</blockquote>


<figure class="highlight c"><figcaption><span>qishi.cpp</span><a href="/downloads/code/qishi.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> goal[<span class="number">5</span>][<span class="number">5</span>]= {</span><br><span class="line">        {<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>},</span><br><span class="line">        {<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">5</span>][<span class="number">5</span>],T,pd;</span><br><span class="line"><span class="keyword">int</span> fx[<span class="number">8</span>]= {<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">-2</span>};</span><br><span class="line"><span class="keyword">int</span> fy[<span class="number">8</span>]= {<span class="number">2</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">1</span>,<span class="number">1</span>};</span><br><span class="line"><span class="keyword">int</span> stx,sty;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++)</span><br><span class="line">            <span class="keyword">if</span>(Map[i][j]!=goal[i][j]) ret++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IDA</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> h = check();</span><br><span class="line">    <span class="keyword">if</span>(!h) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//    if(h-1&gt;left) return false; //where * comes from, pruning procedure</span></span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> x1=x+fx[i];</span><br><span class="line">        <span class="keyword">int</span> y1=y+fy[i];</span><br><span class="line">        <span class="keyword">if</span>(x1&lt;<span class="number">0</span>||x1&gt;<span class="number">4</span>||y1&lt;<span class="number">0</span>||y1&gt;<span class="number">4</span>) <span class="keyword">continue</span>;</span><br><span class="line">        swap(Map[x1][y1],Map[x][y]);</span><br><span class="line">        <span class="keyword">if</span>(IDA(left<span class="number">-1</span>,x1, y1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        swap(Map[x1][y1],Map[x][y]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--) {</span><br><span class="line">        pd=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) {</span><br><span class="line">            <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="comment">//            printf("%s\n", s);</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">5</span>; j++) {</span><br><span class="line">                <span class="keyword">if</span>(s[j]-<span class="string">'0'</span>==<span class="number">0</span>) Map[i][j]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[j]-<span class="string">'0'</span>==<span class="number">1</span>) Map[i][j]=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[j]==<span class="string">'*'</span>) Map[i][j]=<span class="number">2</span>,stx=i,sty=j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//        for(int i=0;i&lt;5;i++){</span></span><br><span class="line"><span class="comment">//            for(int j=0;j&lt;5;j++)</span></span><br><span class="line"><span class="comment">//                printf("%d ", Map[i][j]);</span></span><br><span class="line"><span class="comment">//            printf("\n");</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">15</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(IDA(i,stx, sty)) {</span><br><span class="line">                pd=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">if</span>(pd) <span class="built_in">cout</span>&lt;&lt;pd&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>search</tag>
        <tag>IDA*</tag>
      </tags>
  </entry>
  <entry>
    <title>八数码</title>
    <url>/blog/%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<p>八数码问题，就是在一个含有1-8和x的3*3方格中，每次可以将x与其相邻位置的数字交换。使得最后变成</p>
<p>1 2 3<br>4 5 6<br>7 8 x</p>
<p>你要做的就是实现八数码的解决方案，并要求交换次数最少</p>
<p>输入描述:</p>
<blockquote><p>输入一个3*3的矩阵，包含1-8和x。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出需要移动的步数<br>如果不可能实现，输出-1。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>2  3  4<br>1  5  x<br>7  6  8</p>
</blockquote>

<p>输出</p>
<blockquote><p>19</p>
</blockquote>


<figure class="highlight c"><figcaption><span>bashuma_bfs.cpp</span><a href="/downloads/code/bashuma_bfs.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span>;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">}Q[N], now;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 康拓展开</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">3</span>])</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>]; <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) s[k++] = A[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">        t = s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(s[j] &lt; s[i]) t--;</span><br><span class="line">        res += (t<span class="number">-1</span>) * F[<span class="number">8</span>-i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> rx[] = {<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line"><span class="keyword">int</span> ry[] = {<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x &lt;<span class="number">3</span> &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">-1</span>;</span><br><span class="line">    now.<span class="built_in">step</span> = <span class="number">0</span>;</span><br><span class="line">    Q[++R] = now;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    st[h = Hash(now.mp)] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(h==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R){</span><br><span class="line">        now = Q[L++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">if</span> (check(now.x + rx[i], now.y + ry[i])){</span><br><span class="line">                swap(now.mp[now.x + rx[i]][now.y + ry[i]], now.mp[now.x][now.y]);</span><br><span class="line">                now.x += rx[i], now.y += ry[i];</span><br><span class="line">                now.<span class="built_in">step</span> ++;</span><br><span class="line">                <span class="keyword">int</span> h = Hash(now.mp);</span><br><span class="line">                <span class="keyword">if</span>(h==<span class="number">0</span>) <span class="keyword">return</span> now.<span class="built_in">step</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[h]){</span><br><span class="line">                    st[h] = <span class="number">1</span>;</span><br><span class="line">                    Q[++R] = now;</span><br><span class="line">                }</span><br><span class="line">                now.x -= rx[i], now.y -= ry[i], now.<span class="built_in">step</span>--;</span><br><span class="line">                swap(now.mp[now.x + rx[i]][now.y + ry[i]], now.mp[now.x][now.y]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++) F[i] = F[i<span class="number">-1</span>] * i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'x'</span>) {</span><br><span class="line">                now.x = i, now.y = j;</span><br><span class="line">                s[<span class="number">0</span>] = <span class="string">'9'</span>;</span><br><span class="line">            }</span><br><span class="line">            now.mp[i][j] = s[<span class="number">0</span>] - <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>bashuma_ASTAR.cpp</span><a href="/downloads/code/bashuma_ASTAR.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">400010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> mp[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span>, h;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp;A) <span class="keyword">const</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">step</span>+h &gt; A.<span class="built_in">step</span> + A.h;</span><br><span class="line">    }</span><br><span class="line">}now;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;node&gt; Q;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 康拓展开</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hash</span><span class="params">(<span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">3</span>])</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>]; <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) s[k++] = A[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++){</span><br><span class="line">        t = s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(s[j] &lt; s[i]) t--;</span><br><span class="line">        res += (t<span class="number">-1</span>) * F[<span class="number">8</span>-i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> rx[] = {<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>};</span><br><span class="line"><span class="keyword">int</span> ry[] = {<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x&gt;=<span class="number">0</span> &amp;&amp; x &lt;<span class="number">3</span> &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;<span class="number">3</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">H</span><span class="params">(<span class="keyword">int</span> A[<span class="number">3</span>][<span class="number">3</span>])</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++){</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] == <span class="number">9</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> x = (A[i][j] - <span class="number">1</span>) /<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> y = (A[i][j] - <span class="number">1</span>) %<span class="number">3</span>;</span><br><span class="line">            res += <span class="built_in">abs</span>(i-x) + <span class="built_in">abs</span>(j-y);</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span>{</span><br><span class="line">    now.<span class="built_in">step</span> = <span class="number">0</span>; now.h = H(now.mp);</span><br><span class="line">    Q.push(now);</span><br><span class="line">    <span class="keyword">int</span> h = Hash(now.mp);</span><br><span class="line">    <span class="keyword">if</span>(h==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">        now = Q.top(); Q.pop();</span><br><span class="line">        <span class="keyword">int</span> h = Hash(now.mp);</span><br><span class="line">        <span class="keyword">if</span>(h==<span class="number">0</span>) <span class="keyword">return</span> now.<span class="built_in">step</span>;  <span class="comment">//弹出来时最优</span></span><br><span class="line">        <span class="keyword">if</span>(st[h]) <span class="keyword">continue</span>;  <span class="comment">//类比dijstra</span></span><br><span class="line">        st[h] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++){</span><br><span class="line">            <span class="keyword">if</span> (check(now.x + rx[i], now.y + ry[i])){</span><br><span class="line">                swap(now.mp[now.x + rx[i]][now.y + ry[i]], now.mp[now.x][now.y]);</span><br><span class="line">                now.x += rx[i], now.y += ry[i]; now.<span class="built_in">step</span> ++; now.h = H(now.mp);</span><br><span class="line">                Q.push(now); <span class="comment">// no if before entering priority_queue</span></span><br><span class="line">                now.x -= rx[i], now.y -= ry[i], now.<span class="built_in">step</span>--;</span><br><span class="line">                swap(now.mp[now.x + rx[i]][now.y + ry[i]], now.mp[now.x][now.y]); now.h = H(now.mp);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++) F[i] = F[i<span class="number">-1</span>] * i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) {</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'x'</span>) {</span><br><span class="line">                now.x = i, now.y = j;</span><br><span class="line">                s[<span class="number">0</span>] = <span class="string">'9'</span>;</span><br><span class="line">            }</span><br><span class="line">            now.mp[i][j] = s[<span class="number">0</span>] - <span class="string">'0'</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bfs());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>Search</tag>
        <tag>A*</tag>
      </tags>
  </entry>
  <entry>
    <title>过山车</title>
    <url>/blog/%E8%BF%87%E5%B1%B1%E8%BD%A6/</url>
    <content><![CDATA[<p>给定n个男生和m个女生，坐过山车。过山车每排只有两个位置，且只能是一男一女。已经一些想坐在一起的意愿。<br>求最多可以坐多少排？</p>
<p>输入描述:</p>
<blockquote><p>输入数据的第一行是三个整数K , M , N，分别表示可能的组合数目，女生的人数，男生的人数。K&lt;=1000。<br>N, M&lt;=500.接下来的K行，每行有两个数，分别表示女生A_i愿意和男生B_j坐一起。最后一个0结束输入。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6 3 3<br>1 1<br>1 2<br>1 3<br>2 1<br>2 3<br>3 1<br>0</p>
</blockquote>

<p>输出</p>
<blockquote><p>3</p>
</blockquote>


<figure class="highlight c"><figcaption><span>guoshanche.cpp</span><a href="/downloads/code/guoshanche.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> mp[N][N];</span><br><span class="line"><span class="keyword">int</span> st[N];</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sp</span><span class="params">(<span class="keyword">int</span> v)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="keyword">if</span>(mp[v][i] &amp;&amp; !st[i]){</span><br><span class="line">            st[i] = <span class="number">1</span>; <span class="comment">//类似于减枝</span></span><br><span class="line">            <span class="keyword">if</span>(b[i]==<span class="number">-1</span> || sp(b[i])){</span><br><span class="line">                b[i] = v;</span><br><span class="line">                a[v] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>{</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">-1</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">-1</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">-1</span>){</span><br><span class="line">            <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st); <span class="comment">//对每一i，都要做一次</span></span><br><span class="line">            <span class="keyword">if</span>(sp(i)) ans ++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k) &amp;&amp; k){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">memset</span>(mp, <span class="number">0</span>, <span class="keyword">sizeof</span> mp);</span><br><span class="line">        <span class="keyword">while</span>(k--){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            mp[a][b] = <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>matching</tag>
        <tag>hungarian</tag>
      </tags>
  </entry>
  <entry>
    <title>Theremustbesomethingwrong</title>
    <url>/blog/Theremustbesomethingwrong/</url>
    <content><![CDATA[<p>龙龙得知2020年中国将有2000万至4000万男人娶不到老婆后。他打算好好调查一下是不是人们的感情出现问题。他对n个人进行调查，得到m条信息，每条信息表示为某两人曾经是情侣。由于他不知道这些人的性别，请你帮他判断一下，有没有同性是情侣的情况?</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m。<br>接下来m行，每行两个整数a和b，表示编号为a的人和编号为b的人，曾经是情侣,a≠b。<br>对于100%的数据，n的范围[2,100000],m的范围[0,100000]。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>如果一切正常输出：it’s your own problem<br>如果出现同性是情侣的情况输出：there are must be something wrong</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>4 4<br>1 2<br>2 3<br>3 4<br>4 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>it’s your own problem</p>
</blockquote>

<p>示例2<br>输入</p>
<blockquote><p>3 3<br>1 2<br>1 3<br>2 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>there are must be something wrong</p>
</blockquote>


<figure class="highlight c"><figcaption><span>coloring.cpp</span><a href="/downloads/code/coloring.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[N];</span><br><span class="line"><span class="keyword">int</span> colors[N];</span><br><span class="line"><span class="keyword">bool</span> ff = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> c)</span></span>{</span><br><span class="line">    colors[x] = c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(colors[x]==colors[y]){</span><br><span class="line">            ff = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(colors[y]==<span class="number">0</span>){</span><br><span class="line">            dfs(y, -c);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(colors, <span class="number">0</span>, <span class="keyword">sizeof</span>(colors));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">if</span>(colors[i]==<span class="number">0</span>) dfs(i, <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(ff) <span class="built_in">puts</span>(<span class="string">"it's your own problem"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"there are must be something wrong"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>coloring</tag>
      </tags>
  </entry>
  <entry>
    <title>灌水</title>
    <url>/blog/%E7%81%8C%E6%B0%B4/</url>
    <content><![CDATA[<p>Farmer John已经决定把水灌到他的n(1≤n≤300)块农田，农田被数字1到n标记。把一块土地进行灌水有两种方法，从其他农田饮水，或者这块土地建造水库。 建造一个水库需要花费wi(1≤wi≤105),连接两块土地需要花费pij。 计算Farmer John所需的最少代价。<br>输入描述:</p>
<blockquote><p>第一行：一个数n。</p>
<p>第二行到第n+1行：第i+1行含有一个数wi。</p>
<p>第n+2行到第2∗n+1行：第n+1+i行有n个被空格分开的数，第j个数代表pij。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>一个单独的数代表最小代价.</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>4<br>5<br>4<br>4<br>3<br>0 2 2 2<br>2 0 3 3<br>2 3 0 4<br>2 3 4 0</p>
</blockquote>

<p>输出</p>
<blockquote><p>9</p>
</blockquote>



<figure class="highlight c"><figcaption><span>guanshui.cpp</span><a href="/downloads/code/guanshui.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>{</span></span><br><span class="line">    <span class="keyword">int</span> a, b, v;</span><br><span class="line">}edges[N*N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Edge &amp;a, Edge&amp;b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a.v &lt; b.v;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line">        edges[++tot].a = <span class="number">0</span>, edges[tot].b = i, edges[tot].v = val;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val);</span><br><span class="line">            <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">                edges[++tot].a= i, edges[tot].b = j, edges[tot].v = val;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    sort(edges+<span class="number">1</span>, edges+tot+<span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++){</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(edges[i].a);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="built_in">find</span>(edges[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b) fa[a] = b, ans += edges[i].v;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>昂贵的聘礼</title>
    <url>/blog/%E6%98%82%E8%B4%B5%E7%9A%84%E8%81%98%E7%A4%BC/</url>
    <content><![CDATA[<p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。<br>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p>输入描述:</p>
<blockquote><p>输入第一行是两个整数M，N，依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。对于100%的数据，N∈[1,100],M∈[1,100].</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出最少需要的金币数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>1 4<br>10000 3 2<br>2 8000<br>3 5000<br>1000 2 1<br>4 200<br>3000 2 1<br>4 200<br>50 2 0</p>
</blockquote>

<p>输出</p>
<blockquote><p>5250</p>
</blockquote>



<figure class="highlight c"><figcaption><span>angguipinli.cpp</span><a href="/downloads/code/angguipinli.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> level[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span>{ <span class="comment">//小根堆</span></span><br><span class="line">        <span class="keyword">return</span> v &gt; A.v;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[N];</span><br><span class="line">priority_queue&lt;Node&gt; Q;</span><br><span class="line"><span class="keyword">int</span> dis[N], st[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node in Q is different from node used in input. Q stores (index, dis[index])</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> L)</span></span>{ <span class="comment">//[L, L+m]</span></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.push({<span class="number">0</span>, <span class="number">0</span>});</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">        Node tmp = Q.top();Q.pop();</span><br><span class="line">        <span class="keyword">int</span> k = tmp.to;</span><br><span class="line">        <span class="keyword">if</span>(st[k]) <span class="keyword">continue</span>;</span><br><span class="line">        st[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[k].<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">int</span> y = edges[k][i].to;</span><br><span class="line">            <span class="keyword">int</span> v = edges[k][i].v;</span><br><span class="line">            <span class="keyword">if</span>(level[y]&lt;L || level[y] &gt; L+m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[y] &gt; dis[k] + v){</span><br><span class="line">                dis[y] = dis[k] + v;</span><br><span class="line">                Q.push({y, dis[y]});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, dis[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> x, k, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){ <span class="comment">//该物品编号为i</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;level[i], &amp;k);</span><br><span class="line">        edges[<span class="number">0</span>].push_back({i, x}); <span class="comment">//编号， 价格</span></span><br><span class="line">        <span class="keyword">while</span>(k--){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;y, &amp;x);</span><br><span class="line">            edges[y].push_back({i, x}); <span class="comment">// 替代品x到target i插入价格为y的边</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++){</span><br><span class="line">        Dijstra(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>dijstra</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/blog/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>两次dfs， 第一次求出son[x], 即重儿子的编号； 第二次求出top[x], 即x所在重链的根<br>结论， 每个点最多跳logn条重链，就可以到达树的根</p>
<p>用树链剖分可以求LCA</p>
<p>输入描述:</p>
<blockquote><p>n代表点的个数<br>n-1条边</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>i, son[i], top[i]</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>14 1<br>1 2<br>1 3<br>1 4<br>2 5<br>2 6<br>6 11<br>6 12<br>3 7<br>4 8<br>4 9<br>4 10<br>9 13<br>13 14<br>8 14 // m</p>
</blockquote>

<p>输出</p>
<blockquote><p>1 4 1<br>2 6 2<br>3 7 3<br>4 9 1<br>5 0 5<br>6 11 2<br>7 0 3<br>8 0 8<br>9 13 1<br>10 0 10<br>11 0 2<br>12 0 12<br>13 14 1<br>14 0 1<br>4</p>
</blockquote>


<img src="/downloads/imgs/shulian.png" class="example" title="title exg" alt="alt exg">

<figure class="highlight c"><figcaption><span>shulian.cpp</span><a href="/downloads/code/shulian.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], dep[N], son[N], top[N], sz[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get son vector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x] = f, dep[x] = d, sz[x] = <span class="number">1</span>, son[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x, d+<span class="number">1</span>);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]] &lt; sz[y]) son[x] = y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// get top vector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>{</span><br><span class="line">    top[x] = tp; ID[x] = ++tot;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs2(son[x], x, tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y, x, y);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// a和b走向一条重链</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[a]!=top[b]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]] &gt; dep[top[b]]){</span><br><span class="line">            <span class="comment">// ID[top[a]], ID[a] 是一段连续的区间</span></span><br><span class="line">            a = fa[top[a]];</span><br><span class="line">        }<span class="keyword">else</span> b = fa[top[b]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dep[a] &gt; dep[b] ? b: a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, i, son[i], top[i]);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 8 jumps to 8, fa[8] = 4Œ</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LCA(a, b));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>动态差分</title>
    <url>/blog/%E5%8A%A8%E6%80%81%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>有n个点的一棵树，有m个操作，分为两类：<br>(1):1 x y d:把x到y路径上每个点的权值加d<br>(2):2 x:询问x点的权值</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m<br>接下来n-1行，每行两个整数，表示一条边<br>接下来m行，每行两个操作中的一个。<br>n,m&lt;=10^5</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个2操作，输出结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 4<br>1 2<br>1 3<br>3 4<br>3 5<br>1 3 4 1<br>2 3<br>1 1 5 2<br>2 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>3</p>
</blockquote>

<p>说明</p>
<blockquote><p>区别：动态回答询问</p>
</blockquote>


<figure class="highlight c"><figcaption><span>dongtaichafen.cpp</span><a href="/downloads/code/dongtaichafen.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次修改路径，而非一个点, 区别于苹果树，同于找路径</span></span><br><span class="line"><span class="comment">// 要求动态回答询问， 区别于松鼠的新家，路径更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Two mistakes from LCA, (1) fa[N][S+2], (2) return after goUp.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">2</span>], dep[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Lid[N], Rid[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    Lid[x] = ++tot;</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f]+ <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    }</span><br><span class="line">    Rid[x] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[a] &lt; dep[b]) swap(a,b);</span><br><span class="line">    goUp(a, dep[a]-dep[b]);</span><br><span class="line">    <span class="keyword">if</span>(a==b ) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[a][i] != fa[b][i])</span><br><span class="line">            a = fa[a][i], b= fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span>{</span></span><br><span class="line">    LL C[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=tot){</span><br><span class="line">            C[x] += d;</span><br><span class="line">            x += x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x){</span><br><span class="line">            res += C[x];</span><br><span class="line">            x -= x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}<span class="built_in">bit</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n ,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back({b, i});</span><br><span class="line">        edges[b].push_back({a, i});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x, y, d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x ,&amp;y, &amp;d);</span><br><span class="line">            <span class="keyword">int</span> c = lca(x, y);</span><br><span class="line"><span class="comment">//            printf("lca = %d %d %d\n", x, y, c);</span></span><br><span class="line">            <span class="keyword">int</span> e = fa[c][<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">bit</span>.add(Lid[x], d);</span><br><span class="line">            <span class="built_in">bit</span>.add(Lid[y], d);</span><br><span class="line">            <span class="built_in">bit</span>.add(Lid[c], -d);</span><br><span class="line">            <span class="keyword">if</span>(e)<span class="built_in">bit</span>.add(Lid[e], -d); <span class="comment">// if is crucial!</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="built_in">bit</span>.sum(Rid[x]) - <span class="built_in">bit</span>.sum(Lid[x] <span class="number">-1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>路径更新</title>
    <url>/blog/%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>给出一棵 n 个结点的树，有m个操作，每次把一条路径上每条边都加上1，最后按照每条边的输入顺序，输出每个条被增加的次数。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m<br>接下来n-1行，每行两个整数，表示一条边<br>接下来m行，每行两个整数a和b，表示把a到b的路径上每条边都加1。<br>n, m&lt;=10^5</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>按照边输入的顺序，输出每条边被增加的次数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 3<br>1 2<br>1 3<br>3 4<br>3 5<br>1 4<br>1 5<br>2 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>3<br>1<br>1</p>
</blockquote>


<figure class="highlight c"><figcaption><span>lujinggengxin.cpp</span><a href="/downloads/code/lujinggengxin.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">int</span> ans[N], ID[N]; <span class="comment">//map node id to edge id</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, id;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], dep[N];</span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f] +<span class="number">1</span>, dis[x] = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        ID[y] = edges[x][i].id;  <span class="comment">// ID maps y to edge id;</span></span><br><span class="line">        dfs(y, x, d + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line"><span class="comment">//  starts from 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    goUp(x, dep[x]-dep[y]);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x; <span class="comment">// easy to forget</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y= fa[y][i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(y, x);</span><br><span class="line">        cnt[x] += cnt[y];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// crucial</span></span><br><span class="line">    ans[ID[x]] = cnt[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back({b, i});</span><br><span class="line">        edges[b].push_back({a, i});</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> c = lca(a, b);</span><br><span class="line">        cnt[a]++, cnt[b]++, cnt[c]-=<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>chafen</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>松鼠的新家</title>
    <url>/blog/%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/</url>
    <content><![CDATA[<p>松鼠的新家是一棵树，前几天刚刚装修了新家，新家有n个房间，并且有n-1根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在“树”上。松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去a_1，再去a_2，……，最后到a_n，去参观新家。</p>
<p>可是这样会导致维尼重复走很多房间，懒惰的维尼不听地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。维尼是个馋家伙，立马就答应了。</p>
<p>现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。因为松鼠参观指南上的最后一个房间an是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。</p>
<p>输入描述:</p>
<blockquote><p>第一行一个整数n，表示房间个数 2&lt;=n&lt;=300000;</p>
<p>第二行n个整数，依次描述 a1~an。</p>
<p>接下来n-1行，每行两个整数x，y，表示标号x和y的两个房间之间有树枝相连。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>一共n行，第i行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5<br>1 4 5 3 2<br>1 2<br>2 4<br>2 3<br>4 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>2<br>1<br>2<br>1</p>
</blockquote>

<p>说明</p>
<blockquote><p>有n个点的一棵树， 沿着a1~an顺序去访问每个点， 路径上经过的点都要被加上一次，最后输出每个点被加的次数。</p>
</blockquote>


<figure class="highlight c"><figcaption><span>songshuhome.cpp</span><a href="/downloads/code/songshuhome.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], dep[N];</span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f] +<span class="number">1</span>, dis[x] = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x, d + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line"><span class="comment">//  starts from 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    goUp(x, dep[x]-dep[y]);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x; <span class="comment">// easy to forget</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y= fa[y][i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(y, x);</span><br><span class="line">        cnt[x] += cnt[y];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;path[i]);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) printf("%d ", fa[i][0]);</span></span><br><span class="line"><span class="comment">//    puts("");</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        a = path[i], b = path[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> c = lca(a, b);</span><br><span class="line"><span class="comment">//        printf("%d %d %d\n", a, b, c);</span></span><br><span class="line">        cnt[a]++, cnt[b]++, cnt[c]--, cnt[fa[c][<span class="number">0</span>]]--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) cnt[path[i]]--; <span class="comment">//why?</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>chafen</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>树上两点距离</title>
    <url>/blog/%E6%A0%91%E4%B8%8A%E4%B8%A4%E7%82%B9%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>给定一棵树，求树上两点间的距离。<br>输入描述:</p>
<blockquote><p>第一行两个整数n和m，表示点的个数和询问个数。<br>接下来n-1行，每行三个整数a，b，c，表示a和b有长度为c的边连接。<br>接下来m行，表示有m个询问，a和b，输出a和b的距离。<br>n和m的范围10^5;  边的长度不超过10^4.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问输出相应的结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 4<br>1 2 1<br>1 3 2<br>2 4 3<br>2 5 4<br>1 2<br>2 3<br>4 5<br>3 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>3<br>7<br>6</p>
</blockquote>


<figure class="highlight c"><figcaption><span>shuliangdian.cpp</span><a href="/downloads/code/shuliangdian.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, S = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">2</span>]; <span class="comment">//crucial!</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edges[N];</span><br><span class="line"><span class="keyword">int</span> dep[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//f can't be -1, because of dep[f];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f] + <span class="number">1</span>, dis[x] = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> j = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(j==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(j, x, d + edges[x][i].val);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[a]&lt;dep[b]) swap(a, b);</span><br><span class="line">    goUp(a, dep[a] - dep[b]);</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(fa[a][i] != fa[b][i]){</span><br><span class="line">            a = fa[a][i];  b = fa[b][i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[a].push_back((Node){b, c});</span><br><span class="line">        edges[b].push_back((Node){a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> c = LCA(a, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[a] + dis[b] - <span class="number">2</span>*dis[c]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>找路径</title>
    <url>/blog/%E6%89%BE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>给定一棵含有n个节点的树，每个点上都有一个权值，有m个操作属于以下两种之一：</p>
<p>0 x y: 把x点的权值改为y</p>
<p>1 x: 询问从0出发，经过x的路径，最大和是多少？</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m<br>接下来n-1，每行两个整数，表示树上的一条边。<br>接下一行n个整数，表示每个节点上的权值v。<br>接下来m行，每行表示一个询问。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问，输出一个整数</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6 5<br>0 1<br>1 2<br>0 3<br>3 4<br>5 3<br>7 -5 100 20 -5 -7<br>1 1<br>1 3<br>0 2 -1<br>1 1<br>1 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>102<br>27<br>2<br>20</p>
</blockquote>


<figure class="highlight c"><figcaption><span>zhaolujing.cpp</span><a href="/downloads/code/zhaolujing.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[N];</span><br><span class="line"><span class="keyword">int</span> val[N]; <span class="comment">// number on this node</span></span><br><span class="line"><span class="keyword">int</span> Lid[N], Rid[N], tot;</span><br><span class="line"><span class="keyword">int</span> Line[N]; <span class="comment">//map from dfs_id to original id</span></span><br><span class="line">LL dis[N]; <span class="comment">// accumulated number from root till this node</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, LL d)</span></span>{</span><br><span class="line">    Lid[x] = ++tot; dis[x] = d; Line[tot] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> j = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(j==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(j, x, d + val[j]);</span><br><span class="line">    }</span><br><span class="line">    Rid[x] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    LL mx, add;</span><br><span class="line">}tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].mx = <span class="built_in">max</span>(tree[p&lt;&lt;<span class="number">1</span>].mx, tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].L = L, tree[p].R = R;</span><br><span class="line">    tree[p].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L==R){</span><br><span class="line">        tree[p].mx = dis[Line[L]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R )&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    LL &amp;t = tree[p].add;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].add += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].mx += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx += t;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L == L &amp;&amp; tree[p].R ==R){</span><br><span class="line">        tree[p].add += x;</span><br><span class="line">        tree[p].mx += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[p].L + tree[p].R )&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        update(L, mid, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        update(mid+<span class="number">1</span>, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L == L &amp;&amp; tree[p].R ==R ){</span><br><span class="line">        <span class="keyword">return</span> tree[p].mx;</span><br><span class="line">    }</span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[p].L + tree[p].R) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(L,R, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(query(L, mid, p&lt;&lt;<span class="number">1</span>), query(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) edges[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//  dfs order</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>, val[<span class="number">0</span>]);</span><br><span class="line">    build(<span class="number">1</span>, tot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">            update(Lid[b], Rid[b], c-val[b], <span class="number">1</span>); <span class="comment">// segment tree supports dfs_id manipulation</span></span><br><span class="line">            val[b] = c;  <span class="comment">// original id</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(Lid[b], Rid[b], <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>seg_tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果树</title>
    <url>/blog/%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<p>在卡卡的房子外面，有一棵苹果树。每年的春天，树上总会结出很多的苹果。卡卡非常喜欢吃苹果，所以他一直都精心的呵护这棵苹果树。我们知道树是有很多分叉点的，苹果会长在枝条的分叉点上面，且不会有两个苹果结在一起。卡卡很想知道一个分叉点所代表的子树上所结的苹果的数目，以便研究苹果树哪些枝条的结果能力比较强。<br>卡卡所知道的是，每隔一些时间，某些分叉点上会结出一些苹果，但是卡卡所不知道的是，总会有一些调皮的小孩来树上摘走一些苹果。<br>于是我们定义两种操作：<br>C x 表示编号为x的分叉点的状态被改变(原来有苹果的话，就被摘掉，原来没有的话，就结出一个苹果)<br>Q x 查询编号为x的分叉点所代表的子树中有多少个苹果<br>我们假定一开始的时候，树上全都是苹果，也包括作为根结点的分叉1。</p>
<p>输入描述:</p>
<blockquote><p>第一行一个数N<br>接下来n-1行,每行2个数u,v,表示分叉点u和分叉点v是直接相连的。<br>再接下来一行一个数M表示询问数<br>接下来M行,表示询问,询问的格式如题目所述Q x或者C x<br>n,m不超过 10^5;</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个Q x的询问,请输出相应的结果,每行输出一个</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>3<br>1 2<br>1 3<br>3<br>Q 1<br>C 2<br>Q 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>3<br>2</p>
</blockquote>

<p>说明:</p>
<blockquote><p>给定一棵根节点为1，包含n个节点的树， 每个节点的初始值为1， m个操作属于以下几种：<br>1 x:反正x节点的状态， 1变0， 0变1<br>2 x:询问x对应子树中的和</p>
</blockquote>


<figure class="highlight c"><figcaption><span>pingguoshu.cpp</span><a href="/downloads/code/pingguoshu.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L[M], R[M], tot;</span><br><span class="line"><span class="keyword">int</span> val[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span>{</span></span><br><span class="line">    <span class="keyword">int</span> C[M];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=n){</span><br><span class="line">            C[x] += t;</span><br><span class="line">            x += x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x){</span><br><span class="line">            res += C[x];</span><br><span class="line">            x -= x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}<span class="built_in">bit</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    L[x] = ++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    }</span><br><span class="line">    R[x] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back({b});</span><br><span class="line">        edges[b].push_back({a});</span><br><span class="line">        <span class="built_in">bit</span>.add(i,<span class="number">1</span>);</span><br><span class="line">        val[i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    val[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bit</span>.add(n, <span class="number">1</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个点的新编号是L[x], 管理的区间是[L[x], R[x]]</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单点修改， 区间查询</span></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, s, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'C'</span>) {</span><br><span class="line">            <span class="built_in">bit</span>.add(L[x], -val[x]);</span><br><span class="line">            val[x] = -val[x];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> m = <span class="built_in">bit</span>.sum(R[x]) - <span class="built_in">bit</span>.sum(L[x]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>bit_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/blog/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p>给定一棵树，求出这棵树的直径，即两个节点距离的最大值。</p>
<p>输入描述:</p>
<blockquote><p>输入第一行，一个整数n;<br>接下来n−1行，每行三个整数a,b,c，表示连接节点a和b的边长为c</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出这棵树的直径。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6<br>0 1 3<br>1 5 4<br>1 2 2<br>2 3 1<br>2 4 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>11</p>
</blockquote>

<p>说明</p>
<blockquote><p>csacademy.com/app/graph_editor</p>
</blockquote>


<figure class="highlight c"><figcaption><span>tree_radius1.cpp</span><a href="/downloads/code/tree_radius1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, R=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dis &gt; ans) {ans = dis, R = x;}</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x, dis + edges[x][i].val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[a].push_back({b,c});</span><br><span class="line">        edges[b].push_back({a,c});</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs(R, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>tree_radius2.cpp</span><a href="/downloads/code/tree_radius2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> fir = <span class="number">0</span>, sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t= dfs(y, x) + edges[x][i].val;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;fir){</span><br><span class="line">            sec = fir;</span><br><span class="line">            fir = t;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; sec)</span><br><span class="line">            sec = t;</span><br><span class="line">    }</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, fir+sec);</span><br><span class="line">    <span class="keyword">return</span> fir;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[a].push_back({b,c});</span><br><span class="line">        edges[b].push_back({a,c});</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表</title>
    <url>/blog/ST%E8%A1%A8/</url>
    <content><![CDATA[<p>有一个长度为n的数组A，有m个询问，每次你需要回答在区间[L,R]内的数的最大值。</p>
<p>输入描述:</p>
<blockquote><p>输入的第一行是两个整数n,m,表示数组长度和询问个数。<br>第二行n个元素，表示A数组。<br>接下来m行，每行两个整数L和R，表示一个区间。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问，输出相应的结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 3<br>4 5 2 3 8<br>3 4<br>3 5<br>2 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>3<br>8<br>5</p>
</blockquote>

<p>说明</p>
<blockquote><p>n,m&lt;=10^5</p>
</blockquote>


<figure class="highlight c"><figcaption><span>st1.cpp</span><a href="/downloads/code/st1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = a[L];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = R-L +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=<span class="built_in">step</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)){</span><br><span class="line">            res = <span class="built_in">max</span>(res, S[L][i]);</span><br><span class="line">            L += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        S[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) {</span><br><span class="line">            <span class="keyword">int</span> t = i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            S[i][j] = <span class="built_in">max</span>(S[i][j<span class="number">-1</span>], S[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>st2.cpp</span><a href="/downloads/code/st2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L+(<span class="number">1</span>&lt;&lt;k)&lt;R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>) k++;</span><br><span class="line">    res = <span class="built_in">max</span>(S[L][k], S[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        S[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) {</span><br><span class="line">            <span class="keyword">int</span> t = i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            S[i][j] = <span class="built_in">max</span>(S[i][j<span class="number">-1</span>], S[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>st3.cpp</span><a href="/downloads/code/st3.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][<span class="number">17</span>];</span><br><span class="line"><span class="keyword">int</span> Log[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k= Log[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">max</span>(S[L][k], S[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        S[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Log[<span class="number">0</span>] =<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Log[i] = Log[i&gt;&gt;<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) {</span><br><span class="line">            <span class="keyword">int</span> t = i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            S[i][j] = <span class="built_in">max</span>(S[i][j<span class="number">-1</span>], S[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>data_structure</tag>
        <tag>beizeng</tag>
      </tags>
  </entry>
  <entry>
    <title>MinMax</title>
    <url>/blog/MinMax/</url>
    <content><![CDATA[<img src="/downloads/imgs/minmax.png" class="example" title="title exg" alt="alt exg">

<p>输入描述:</p>
<blockquote><p>输入的第一行是两个整数n k。<br>接下来一行n个整数，表示数列a_i</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出两行，每行n-k+1个数，第一行是b数组，第二行是c数组。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>8 3<br>1 3 -1 -3 5 3 6 7</p>
</blockquote>

<p>输出</p>
<blockquote><p>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=10^6</p>
</blockquote>


<figure class="highlight c"><figcaption><span>minmax.cpp</span><a href="/downloads/code/minmax.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> tt=<span class="number">0</span>, rr = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; a[q[rr]]&gt;=a[i]) rr--;</span><br><span class="line">        q[++rr] = i;</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; i-q[tt]&gt;=k) tt++;</span><br><span class="line">        ans[i] = q[tt];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[ans[i]]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    tt =<span class="number">0</span>, rr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; a[q[rr]]&lt;=a[i]) rr--;</span><br><span class="line">        q[++rr] = i;</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; i-q[tt]&gt;=k) tt++;</span><br><span class="line">        ans[i] = q[tt];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[ans[i]]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>monotone_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>最大面积</title>
    <url>/blog/%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>现在有由n个宽度为1，高度分别为$h_1,h_2,…h_n$的长方形从左到右依次排列组成的柱形图。问里面包含的长方形的最大面积是多少？</p>
<p>输入描述:</p>
<blockquote><p>第一行一个整数n，表示柱形个数。<br>接下来一行n个整数，表示每个柱形的高度$h_i$。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出最大的矩形面积。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>7<br>2 1 4 5 1 3 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>8</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=10^5.</p>
</blockquote>


<figure class="highlight c"><figcaption><span>zuidamianji.cpp</span><a href="/downloads/code/zuidamianji.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line">    stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">0</span> &amp;&amp; h[stk[t]] &gt;= h[i]) t--;</span><br><span class="line">        L[i] = stk[t];</span><br><span class="line">        stk[++t] = i;</span><br><span class="line">    }</span><br><span class="line">    stk[<span class="number">0</span>] = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span> &amp;&amp; h[stk[t]] &gt;= h[i]) t--;</span><br><span class="line">        R[i] = stk[t];</span><br><span class="line">        stk[++t] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) printf("%d ", L[i]);</span></span><br><span class="line"><span class="comment">//    puts("");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) printf("%d ", R[i]);</span></span><br><span class="line"><span class="comment">//    puts("");</span></span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1L</span>L * (R[i]-L[i] <span class="number">-1</span>) * h[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>monotone_stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Sort Template</title>
    <url>/blog/hello-world/</url>
    <content><![CDATA[<p>Quick sort is one of the most fundamental algorithms.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo s -p 8001</span><br></pre></td></tr></table></figure>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h3><figure class="highlight c"><figcaption><span>quick_sort.cpp</span><a href="/downloads/code/quick_sort.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = q[l], i=l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j){</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q[i], q[j]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    quick_sort(q, l ,j);</span><br><span class="line">    quick_sort(q, j+<span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>template</category>
      </categories>
      <tags>
        <tag>basic_algo</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepSnake</title>
    <url>/blog/DeepSnake/</url>
    <content><![CDATA[<h2 id="Traditional-snake-algorithms"><a href="#Traditional-snake-algorithms" class="headerlink" title="Traditional snake algorithms:"></a>Traditional snake algorithms:</h2><blockquote><p>given an initial contour, traditional snake algorithms treat the coordinates<br>of the vertices as a set of variables and optimize an energy functional with respect to these variables.<br>Active contour models could optimize the contour to the object boundary. The energy functional is typically<br>nonconvex, the deformation process tend to find local optimal solutions.</p>
</blockquote>

<h2 id="Network-Architecture"><a href="#Network-Architecture" class="headerlink" title="Network Architecture:"></a>Network Architecture:</h2><blockquote><p>Deep snake consists of three parts: <span style="color:red">a backbone</span>, <span style="color:red">a fusion block</span> and <span style="color:red">a prediction head</span>. The backbone is comprised<br> of 8 “CirConvBn-ReLU” layers and <em>uses residual skip connections for all layers</em>. The fusion block aims to fuse<br> the information across all contour points at multiple scales.</p>
</blockquote>
<img src="/downloads/imgs/deepsnake_architecture.jpg" class="example" title="title exg" alt="alt exg">

<h2 id="Detail"><a href="#Detail" class="headerlink" title="Detail:"></a>Detail:</h2><blockquote><p>Add deep snake to an object detection model. The detector first produces objet boxes that are used to construct<br>diamond contours. Then deep snake deforms the diamond vertices to object extreme points, which are used to<br>construct octagon contours. Finally, the approach takes <strong>octagons as initial contours and performs iterative<br>contour deformation to obtain the object shape</strong>.</p>
</blockquote>

<h2 id="Initial-contour-proposal"><a href="#Initial-contour-proposal" class="headerlink" title="Initial contour proposal:"></a>Initial contour proposal:</h2><blockquote><p>The octagon is formed by four extreme points, which are top, leftmost, bottom, rightmost pixels in an object,<br>given a detected object box, extract four points centered at top, left, bottom, right box borders and then<br>connect them to get a diamond contour.</p>
</blockquote>

<h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization:"></a>Optimization:</h2><blockquote><p>Regressing the offsets in one pass in challenging, especially for vertices far away from the object. <strong>Use an<br>iterative optimization fashion</strong>. Solve the localization errors from the detector.</p>
</blockquote>

<h2 id="Multi-component-objects"><a href="#Multi-component-objects" class="headerlink" title="Multi-component objects:"></a>Multi-component objects:</h2><blockquote><p>use RoIAlign to extract a feature map and adds a detector branch on the feature map to produce the component boxes.</p>
</blockquote>

<img src="/downloads/imgs/RoIAlign.png" class="example" title="title exg" alt="alt exg">




]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>Instance Segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>动态区间求和</title>
    <url>/blog/%E5%8A%A8%E6%80%81%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个长度为n的序列，有m个操作，需要实现区间加一个值和统计区间和。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m，表示有一个长度为n个序列和m个操作。<br>第二行n个整数表示初始序列。<br>接下来m行，每行的内容属于以下一种：<br>Add x y a：把在区间[x,y]内的数都加上a（a∈[-10000,10000]）。<br>Query x y：求出区间[x,y]中所有数的和。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问输出相应的结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 5<br>1 2 3 4 5<br>Query 1 5<br>Add 1 3 5<br>Query 3 5<br>Add 3 5 10<br>Query 1 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>15<br>17<br>60</p>
</blockquote>

<p>说明</p>
<blockquote><p>n,m&lt;=10^5</p>
</blockquote>


<figure class="highlight c"><figcaption><span>lazy_seg_tree.cpp</span><a href="/downloads/code/lazy_seg_tree.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    LL tag, sum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span></span>{ <span class="keyword">return</span> (R-L+<span class="number">1</span>);}</span><br><span class="line"></span><br><span class="line">}tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].sum = tree[p&lt;&lt;<span class="number">1</span>].sum + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].L = L, tree[p].R =R;</span><br><span class="line">    <span class="keyword">if</span>(L==R){</span><br><span class="line">        tree[p].sum = A[L];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    LL &amp;t = tree[p].tag;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].tag += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].sum += t * tree[p&lt;&lt;<span class="number">1</span>].len();</span><br><span class="line"></span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum += t*tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空懒标记</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L ==L &amp;&amp; tree[p].R ==R){</span><br><span class="line">        tree[p].tag += x;</span><br><span class="line">        tree[p].sum += tree[p].len() * x; <span class="comment">// forget;</span></span><br><span class="line">        <span class="comment">//forget</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = tree[p].L + tree[p].R &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        update(L, mid, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        update(mid+<span class="number">1</span>, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L==L &amp;&amp; tree[p].R==R){</span><br><span class="line">        <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//    forget</span></span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = tree[p].L + tree[p].R &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> query(L, mid, p&lt;&lt;<span class="number">1</span>) + query(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>){</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            update(a, b, c, <span class="number">1</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(a, b, <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>chunji_nowcoder</tag>
        <tag>lazy_tag</tag>
      </tags>
  </entry>
  <entry>
    <title>区间统计</title>
    <url>/blog/%E5%8C%BA%E9%97%B4%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>给定一个1到n的排列A数组，有m个询问，每次查询下标在[L,R]范围内，小于等于x的数的个数。</p>
<p>输入描述:</p>
<blockquote><p>第一行2个整数n和m。<br>第二行n个整数，表示一个排列。<br>接下来m行，每行3个整数L,R,x。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问，输出相应的结果</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 3<br>4 3 2 5 1<br>1 2 3<br>2 4 3<br>3 5 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>2<br>2</p>
</blockquote>

<p>说明</p>
<blockquote><p>n,m&lt;=10^5</p>
</blockquote>


<figure class="highlight c"><figcaption><span>qujiantongji_fenkuai.cpp</span><a href="/downloads/code/qujiantongji_fenkuai.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N], B[N];</span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ka = L / S, kb = R / S;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ka == kb) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) {</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; (ka + <span class="number">1</span>) * S; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ka + <span class="number">1</span>; i &lt; kb; i++) {</span><br><span class="line">            res += upper_bound(B + i * S, B + i * S + S, x) - (B + i * S);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = kb * S; i &lt;= R; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        B[i] = A[i];</span><br><span class="line">    }</span><br><span class="line">    S = <span class="built_in">sqrt</span>(n*<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i+S<span class="number">-1</span>&lt;=n;i+=S){</span><br><span class="line">        sort(B+i, B+i+S);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> a, b, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">        <span class="keyword">int</span> ans = query(a, b, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>qujiantongji2.cpp</span><a href="/downloads/code/qujiantongji2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N], sum[<span class="number">320</span>][N];</span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ka = L / S, kb = R / S;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ka == kb) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) {</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; (ka + <span class="number">1</span>) * S; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ka + <span class="number">1</span>; i &lt; kb; i++) {</span><br><span class="line">            res += sum[i][x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = kb * S; i &lt;= R; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    S = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        sum[i/S][A[i]] ++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum[i][j] += sum[i][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> a, b, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">        <span class="keyword">int</span> ans = query(a, b, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>qujiantongji_fenwick_tree.cpp</span><a href="/downloads/code/qujiantongji_fenwick_tree.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> C[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> x, id, flag;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;query[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n){</span><br><span class="line">        C[x] += a;</span><br><span class="line">        x += x&amp;-x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x){</span><br><span class="line">        res+= C[x];</span><br><span class="line">        x-= x&amp;-x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class="number">-1</span>] + A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        C[i] = pre[i] - pre[i-(i&amp;-i)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="keyword">int</span> L, R, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;L, &amp;R, &amp;x);</span><br><span class="line">        query[R].push_back((Node){x, i, <span class="number">1</span>});</span><br><span class="line">        query[L<span class="number">-1</span>].push_back((Node){x, i, <span class="number">-1</span>});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) add(A[i], 1);  wrong</span></span><br><span class="line"><span class="comment">//  下标有序，按序点亮二进制值， 权值树状数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        add(A[i], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;query[i].<span class="built_in">size</span>();j++){</span><br><span class="line">            ans[query[i][j].id] += query[i][j].flag * sum(query[i][j].x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//    离线回答询问,</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>data_structure</tag>
        <tag>fenwick_tree_offline</tag>
        <tag>seg_tree</tag>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title>最优贸易分块</title>
    <url>/blog/%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>C国有 n 座城市，编号是 1 到 n ，编号为 i 的城市有路到编号为 i+1 的城市（编号为 n 的城市没有路到其他的城市）。</p>
<p>C国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。</p>
<p>商人阿龙再次来到C国旅游。他还是想贩卖水晶赚取旅费，在某个城市买入，再另一个城市卖出。</p>
<p>他将从编号为 a 的城市到编号到 b 的城市。请你帮他算算，最多能赚多少钱。</p>
<p>注：他最多进行一次买入和一次卖出。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m，表示n个城市和m个询问。<br>第二行n个整数，表示n座城市水晶的买入和卖出的价格。<br>接下来m行，每行两个整数a,b，表示阿龙要从编号为a的城市到编号为b的城市（保证a&lt;b）。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问输出阿龙最多能赚多少钱。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6 3<br>2 1 3 6 4 5<br>1 2<br>2 4<br>1 6</p>
</blockquote>

<p>输出</p>
<blockquote><p>0<br>5<br>5</p>
</blockquote>

<p>说明</p>
<blockquote><p>从1到2，无法赚钱。<br>从2到4，在编号为2的城市买入，在编号为4的城市卖出。<br>从1到6，在编号为2的城市买入，在编号为4的城市卖出。</p>
</blockquote>


<figure class="highlight c"><figcaption><span>zuiyoumaoyi_fenkuai.cpp</span><a href="/downloads/code/zuiyoumaoyi_fenkuai.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">320</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="keyword">int</span> A[M];</span><br><span class="line"><span class="keyword">int</span> V[N], Mi[N], Mx[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ka = L/S, kb= R/S;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mi = A[L];</span><br><span class="line">    <span class="keyword">if</span>(ka==kb){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;=R;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, A[i] - mi);</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, A[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;(ka+<span class="number">1</span>)*S;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, A[i] - mi);</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, A[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ka+<span class="number">1</span>;i&lt;kb;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(V[i], Mx[i] - mi));</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, Mi[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=kb*S;i&lt;=R;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, A[i] - mi);</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, A[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    S = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/S; i++){</span><br><span class="line">        V[i] = <span class="number">0</span>;</span><br><span class="line">        Mi[i] = <span class="number">1e9</span>;</span><br><span class="line">        Mx[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">int</span> x = i/S;</span><br><span class="line">        V[x] = <span class="built_in">max</span>(V[x], A[i] - Mi[x]);</span><br><span class="line">        Mi[x] = <span class="built_in">min</span>(Mi[x], A[i]);</span><br><span class="line">        Mx[x] = <span class="built_in">max</span>(Mx[x], A[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> ans = query(l, r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuiyoumaoyi_segtree.cpp</span><a href="/downloads/code/zuiyoumaoyi_segtree.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> val, mi, mx;</span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">}tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(Node&amp;root, Node &amp;ls, Node &amp;rs)</span></span>{</span><br><span class="line">    root.val = <span class="built_in">max</span>(<span class="built_in">max</span>(ls.val, rs.val), rs.mx-ls.mi);</span><br><span class="line">    root.mi = <span class="built_in">min</span>(ls.mi, rs.mi);</span><br><span class="line">    root.mx = <span class="built_in">max</span>(ls.mx, rs.mx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].L = L, tree[p].R = R;</span><br><span class="line">    <span class="keyword">if</span>(L==R){</span><br><span class="line">        tree[p].val = <span class="number">0</span>;</span><br><span class="line">        tree[p].mi = A[L];</span><br><span class="line">        tree[p].mx = A[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归完毕，用tree</span></span><br><span class="line">    up(tree[p], tree[p&lt;&lt;<span class="number">1</span>], tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L ==L &amp;&amp; tree[p].R==R){</span><br><span class="line">        <span class="keyword">return</span> tree[p];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = tree[p].L + tree[p].R &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line"><span class="comment">//        准备开始递归</span></span><br><span class="line">        Node B = query(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        Node C = query(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        Node res;</span><br><span class="line">        up(res, B, C);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n ,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R, <span class="number">1</span>).val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuiyoumaoyi_beizeng.cpp</span><a href="/downloads/code/zuiyoumaoyi_beizeng.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> V[N][<span class="number">17</span>], Mi[N][<span class="number">17</span>], Mx[N][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mi = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=<span class="built_in">step</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)){</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(V[L][i], Mx[L][i] - mi));</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, Mi[L][i]);</span><br><span class="line">            L += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        V[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Mi[i][<span class="number">0</span>] = A[i];</span><br><span class="line">        Mx[i][<span class="number">0</span>] = A[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++){</span><br><span class="line"><span class="comment">//      i starts from i cause'  A starts from 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++){</span><br><span class="line">            <span class="keyword">int</span> t = i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            V[i][j] = <span class="built_in">max</span>(<span class="built_in">max</span>(V[i][j<span class="number">-1</span>], V[t][j<span class="number">-1</span>]), Mx[t][j<span class="number">-1</span>] - Mi[i][j<span class="number">-1</span>]);</span><br><span class="line">            Mx[i][j] = <span class="built_in">max</span>(Mx[i][j<span class="number">-1</span>], Mx[t][j<span class="number">-1</span>]);</span><br><span class="line">            Mi[i][j] = <span class="built_in">min</span>(Mi[i][j<span class="number">-1</span>], Mi[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuiyoumaoyi_union_set.cpp</span><a href="/downloads/code/zuiyoumaoyi_union_set.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="comment">// corresponding value from i to root</span></span><br><span class="line"><span class="keyword">int</span> V[N], Mx[N], Mi[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> L, id;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;query[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(fa[x] != x) {</span><br><span class="line">        <span class="keyword">int</span> t = fa[x];</span><br><span class="line">        <span class="comment">// finish calc of father's Mi[t], V[t], Mx[t]</span></span><br><span class="line">        fa[x] = getfa(t);</span><br><span class="line">        <span class="comment">// x--&gt; t --&gt; fa[x]</span></span><br><span class="line">        V[x] = <span class="built_in">max</span>(V[x], <span class="built_in">max</span>(V[t], Mx[t] - Mi[x]));</span><br><span class="line">        Mi[x] = <span class="built_in">min</span>(Mi[x], Mi[t]);</span><br><span class="line">        Mx[x] = <span class="built_in">max</span>(Mx[x], Mx[t]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        Mi[i] = Mx[i] = A[i];</span><br><span class="line">        V[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        query[R].push_back((Node){L, i});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;query[i].<span class="built_in">size</span>();j++){</span><br><span class="line">            <span class="keyword">int</span> L = query[i][j].L;  <span class="comment">//[L, i]</span></span><br><span class="line">            getfa(L);</span><br><span class="line">            ans[query[i][j].id] = V[L];</span><br><span class="line">        }</span><br><span class="line">        fa[i] = i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>data_structure</tag>
        <tag>seg_tree</tag>
        <tag>block</tag>
        <tag>beizeng</tag>
      </tags>
  </entry>
  <entry>
    <title>进电梯</title>
    <url>/blog/%E8%BF%9B%E7%94%B5%E6%A2%AF/</url>
    <content><![CDATA[<p>n个人在排成一队在电梯面前，最前面的人每一秒钟会进行一次选择，有p的概率进电梯，有1-p的概率停在原地。每个人只有他前面的人都进电梯了，他才有可能进电梯。求t秒之后，进电梯人数的期望值。</p>
<p>输入描述:</p>
<blockquote><p>一行三个数n t p（n,t是不超过2000的整数；p是浮点数，范围在[0,1]之间）。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出t秒钟后，电梯中人数的期望值。保留6位小数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>1 1 0.50</p>
</blockquote>

<p>输出</p>
<blockquote><p>0.500000</p>
</blockquote>


<p>填表法：<br>dp[i][j] = dp[i-1][j] * (1-p) + dp[i-1][j-1] * p</p>
<p>刷表法：<br>dp[i+1][j] += dp[i][j] * (1-p)<br>dp[i+1][j+1] += dp[i][j] * p</p>
<figure class="highlight c"><figcaption><span>jindianti.cpp</span><a href="/downloads/code/jindianti.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">double</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;n, &amp;t, &amp;p);</span><br><span class="line"><span class="comment">//    cin&gt;&gt;n&gt;&gt;t&gt;&gt;p;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++){</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] * (<span class="number">1</span>-p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(i,n<span class="number">-1</span>);j++) {</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] * (<span class="number">1</span>-p) + dp[i<span class="number">-1</span>][j<span class="number">-1</span>] * p;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n) dp[i][n] = dp[i<span class="number">-1</span>][n] + dp[i<span class="number">-1</span>][n<span class="number">-1</span>] * p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans += dp[t][i] * i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉苹果树</title>
    <url>/blog/%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<p>给定一棵n个结点的二叉树，你需要选择一棵以1号结点为根，m条边的联通子树，使得所选择的边权值之和最大。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n,m。<br>之后n-1行，每行三个整数x,y,z，表示结点x,y之间有一条权值为z的无向边。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>所选的边的权值和的最大值。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 2<br>1 3 1<br>1 4 10<br>2 3 20<br>3 5 20</p>
</blockquote>

<p>输出</p>
<blockquote><p>21</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=100, m&lt;=n-1.</p>
</blockquote>


<figure class="highlight c"><figcaption><span>erchapingguo1.cpp</span><a href="/downloads/code/erchapingguo1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//70%</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y!=f){</span><br><span class="line">            dfs(y, x);</span><br><span class="line">            val[y] = edge[x][i].val;</span><br><span class="line">            ch[x][k++] = y;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//    printf("%d %d\n", x, k);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ls = ch[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> rs = ch[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(ls==<span class="number">0</span> &amp;&amp; rs==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[x][i] = val[x];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(ls!=<span class="number">0</span> &amp;&amp; rs!=<span class="number">0</span>) {</span><br><span class="line">        DP(ls);</span><br><span class="line">        DP(rs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt;= i; j++)</span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[ls][j] + dp[rs][i - j - <span class="number">1</span>] + val[x]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edge[a].push_back({b, c});</span><br><span class="line">        edge[b].push_back({a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    DP(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>erchapingguo2.cpp</span><a href="/downloads/code/erchapingguo2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y!=f){</span><br><span class="line">            dfs(y, x);</span><br><span class="line">            val[y] = edge[x][i].val;</span><br><span class="line">            ch[x][k++] = y;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k!=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">int</span> ls = ch[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rs = ch[x][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[ls][j] + dp[rs][i - j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        dp[x][i] = dp[x][i<span class="number">-1</span>] + val[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edge[a].push_back({b, c});</span><br><span class="line">        edge[b].push_back({a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>duochapingguo.cpp</span><a href="/downloads/code/duochapingguo.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note that m edges rather than m nodes.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="keyword">int</span> sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i].to, val = edge[x][i].val;</span><br><span class="line">        <span class="keyword">if</span> (y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        <span class="keyword">int</span> mi= <span class="built_in">min</span>(sz[x], m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=mi;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=j;t++) <span class="comment">// t个分给新儿子用,j-t给之前儿子用</span></span><br><span class="line">                tmp[j] = <span class="built_in">max</span>(tmp[j], dp[y][t<span class="number">-1</span>] + dp[x][j-t] + val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[x][j] = <span class="built_in">max</span>(dp[x][j], tmp[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edge[a].push_back((Node){b, c});</span><br><span class="line">        edge[b].push_back((Node){a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>没有上司的舞会</title>
    <url>/blog/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
    <content><![CDATA[<p>有个公司要举行一场晚会。为了让到会的每个人不受他的直接上司约束而能玩得开心，公司领导决定：如果邀请了某个人，那么一定不会再邀请他的直接的上司，但该人的上司的上司，上司的上司的上司……都可以邀请。已知每个人最多有唯一的一个上司。<br>已知公司的每个人参加晚会都能为晚会增添一些气氛，求一个邀请方案，使气氛值的和最大。</p>
<p>输入描述:</p>
<blockquote><p>第1行一个整数N表示公司的人数，。<br>接下一行N个整数。第i行的数表示第i个人的气氛值x，。<br>接N-1下来每行两个整数K，L。表示第K个人是第L个人的上司。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>一个数，表示最大的气氛值和。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>4<br>1 7 3 4<br>1 2<br>2 3<br>2 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>8</p>
</blockquote>

<p>说明</p>
<blockquote><p>你可以认为公司只有唯一的总boss，这个公司的关系图是一棵树。</p>
</blockquote>


<figure class="highlight c"><figcaption><span>wuhui.cpp</span><a href="/downloads/code/wuhui.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i];</span><br><span class="line">        dfs(y);</span><br><span class="line">        dp[x][<span class="number">1</span>] += dp[y][<span class="number">0</span>];</span><br><span class="line">        dp[x][<span class="number">0</span>] += <span class="built_in">max</span>(dp[y][<span class="number">0</span>], dp[y][<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dp[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edge[a].push_back(b);</span><br><span class="line">        cnt[b]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!cnt[i]) {</span><br><span class="line">            t = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    dfs(t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">max</span>(dp[t][<span class="number">0</span>], dp[t][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑病毒</title>
    <url>/blog/%E7%94%B5%E8%84%91%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<p>假设你是一个黑客，入侵了一个有着n台计算机（编号为0,1,2,…n-1）的网络。一共有n种服务，每台计算机都运行着所有的服务。对于每台计算机，你都可以选择一项服务，终止这台计算机和所有与它相邻计算机的该项服务（如果其中一些服务已经停止，则这些服务继续处于停止状态）。你的目标是让尽可能多的服务瘫痪（即：没有任何计算机运行该项服务）。</p>
<p>输入描述:</p>
<blockquote><p>多组数据，以n=0结尾。<br>每组数据第一行包含一个整数n，n&lt;=16。<br>接下来，每行包括m+1个整数，其中第一个整数为m，表示受这台电脑服务的电脑台数；然后m个整数，表示这些电脑的编号。电脑的编号为0到n-1之间的整数。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每组数据，输出完全瘫痪的服务的最大数量。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>3<br>2 1 2<br>2 0 2<br>2 0 1<br>4<br>1 1<br>1 0<br>1 3<br>1 2<br>0</p>
</blockquote>

<p>输出</p>
<blockquote><p>3<br>2</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=16</p>
</blockquote>


<figure class="highlight c"><figcaption><span>diannaobingdu.cpp</span><a href="/downloads/code/diannaobingdu.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> edge[N];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;N], arrive[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n!=<span class="number">0</span>){</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(arrive, <span class="number">0</span>, <span class="keyword">sizeof</span> arrive);</span><br><span class="line">        <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span> edge);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">            edge[i]|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">while</span>(m--)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                edge[i]|= (<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) arrive[i] |= edge[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j;j=(j<span class="number">-1</span>)&amp;i){</span><br><span class="line">                <span class="keyword">if</span>(arrive[j] == (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[i^j] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            dp[i] = ans;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>炮兵阵地</title>
    <url>/blog/%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
    <content><![CDATA[<p>司令部的将军们打算在N<em>M的网格地图上部署他们的炮兵部队。一个N</em>M的地图由N行M列组成，地图的每一格可能是山地（用“H” 表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<img src="/downloads/imgs/paobing.png" class="example" width="500" height="500" title="title exg" alt="alt exg">
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。</p>
<p>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<p>输入描述:</p>
<blockquote><p>文件的第一行包含两个由空格分割开的正整数，分别表示N和M。<br>接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。</p>
</blockquote>

<p>输出描述:</p>
<blockquote><p>文件仅在第一行包含一个整数K，表示最多能摆放的炮兵部队的数量。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 4<br>PHPP<br>PPHH<br>PPPP<br>PHPP<br>PHHP</p>
</blockquote>

<p>输出</p>
<blockquote><p>6</p>
</blockquote>

<p>说明</p>
<blockquote><p>N&lt;=100, M&lt;=10.</p>
</blockquote>



<figure class="highlight c"><figcaption><span>paobingzhendi.cpp</span><a href="/downloads/code/paobingzhendi.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> S[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> ms[M];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100</span>], tot;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1025</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ms);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">            S[i]|= (ms[j]==<span class="string">'H'</span>) &lt;&lt;j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(i&amp;(i&lt;&lt;<span class="number">2</span>))) s[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)</span><br><span class="line">        c[i]  = c[i-lowbit(i)] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]&amp;S[x]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++){</span><br><span class="line">                <span class="keyword">if</span>(s[i] &amp; s[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[j] &amp; S[x<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=tot;k++){</span><br><span class="line">                    <span class="keyword">if</span>(s[i]&amp;s[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(s[j]&amp;s[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">2</span> &amp;&amp; s[k]&amp;S[x<span class="number">-2</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[x][i][j] = <span class="built_in">max</span>(dp[x][i][j], dp[x<span class="number">-1</span>][j][k] + c[s[i]]);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[x][i][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>愤怒的小鸟 (NOIP2016)</title>
    <url>/blog/%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/</url>
    <content><![CDATA[<p>Kiana 最近沉迷于一款神奇的游戏无法自拔。<br>简单来说，这款游戏是在一个平面上进行的。有一架弹弓位于 (0, 0) 处，每次 Kiana 可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 y = ax2 + bx 的曲线，其中 a，b 是 Kiana 指定的参数，且必须满足 a &lt; 0。当小鸟落回地面（即 x 轴）时，它就会瞬间消失。<br>在游戏的某个关卡里，平面的第一象限中有 n 只猪，其中第 i 只猪所在的坐标为 (xi, yi)。如果某只小鸟的飞行轨迹经过了(xi, yi)，那么第 i 只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；如果一只小鸟的飞行轨迹没有经过(xi, yi)，那么这只小鸟飞行的全过程就不会对第 i 只猪产生任何影响。<br>例如，若两只猪分别位于 (1, 3) 和 (3, 3)，Kiana 可以选择发射一只飞行轨迹为 y = -x2 + 4x 的小鸟，这样两只猪就会被这只小鸟一起消灭。<br>而这个游戏的目的，就是通过发射小鸟消灭所有的猪。<br>这款神奇游戏的每个关卡对来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入描述」中详述。<br>假设这款游戏一共有 T 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>第一行包含一个正整数 T，表示游戏的关卡总数。<br>下面依次输入这 T 个关卡的信息。每个关卡第一行包含两个非负整数 n，m，分别表示该关卡中的猪数量和 Kiana 输入的神秘指令类型。<br>接下来的 n 行中，第 i 行包含两个正实数 (xi, yi)，表示第 i 只猪坐标为 (xi, yi)。数据保证同一个关卡中不存在两只坐标完全相同的猪。</p>
<p>保证 1 ≤ n ≤ 18，0 ≤ m ≤ 2，0 &lt; xi, yi &lt; 10，输入中的实数均保留到小数点后两位。</p>
</blockquote>

<p>输出描述</p>
<blockquote><p>对每个关卡依次输出一行答案。<br>输出的每一行包含一个正整数，表示相应的关卡中，消灭所有猪最少需要的小鸟数量。</p>
</blockquote>


<p>示例1<br>输入</p>
<blockquote><p>2<br>2 0<br>1.00 3.00<br>3.00 3.00<br>5 2<br>1.00 5.00<br>2.00 8.00<br>3.00 9.00<br>4.00 8.00<br>5.00 5.00</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>1</p>
</blockquote>

<p>说明</p>
<blockquote><p>这组数据中一共有两个关卡。<br>第一个关卡与「题目描述」中的情形相同，2 只猪分别位于 (1.00, 3.00) 和 (3.00, 3.00)，只需发射一只飞行轨迹为 y = -x2 + 4x 的小鸟即可消灭它们。<br>第二个关卡中有 5 只猪，但经过观察我们可以发现它们的坐标都在抛物线 y = -x2 + 6x 上，故 Kiana 只需要发射一只小鸟即可消灭所有猪。</p>
</blockquote>

<figure class="highlight c"><figcaption><span>fennudexiaoniao.cpp</span><a href="/downloads/code/fennudexiaoniao.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; PDD;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span>&lt;&lt;N;</span><br><span class="line">PDD q[N];</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> path[N][N];</span><br><span class="line"><span class="keyword">int</span> f[M];</span><br><span class="line"><span class="keyword">int</span> lb[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x-y)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+<span class="number">1</span>&lt;<span class="number">1</span>&lt;&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(!(i&gt;&gt;j&amp;<span class="number">1</span>)){</span><br><span class="line">                    lb[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">        <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span> path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) {</span><br><span class="line">            path[i][i] = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (!cmp(q[i].x, q[j].x)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> x1 = q[i].x, y1 = q[i].y, x2 = q[j].x, y2 = q[j].y;</span><br><span class="line">                <span class="keyword">double</span> b = (y1 * x2 * x2 / x1 / x1 - y2) / (x2 * x2 / x1 - x2);</span><br><span class="line">                <span class="keyword">double</span> a = (y1 - b * x1) / x1 / x1;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) {</span><br><span class="line">                    <span class="keyword">double</span> x = q[k].x, y = q[k].y;</span><br><span class="line">                    <span class="keyword">if</span> (!cmp(y, a * x * x + b * x)) path[i][j] |= <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;<span class="number">1</span>&lt;&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> x = lb[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">int</span> state = path[x][j];</span><br><span class="line">                f[i|state] = <span class="built_in">min</span>(f[i|state], f[i] +<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<img src="/downloads/imgs/itr-1000.png" class="example" width="500" height="500" title="title exg" alt="alt exg">
]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>方格取数</title>
    <url>/blog/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/</url>
    <content><![CDATA[<p>给你一个n∗n的格子的棋盘，每个格子里面有一个非负整数。<br>你需要从中取出若干个数，使得任意两个数所在的格子没有公共边，就是说所取的数所在的2个格子不能相邻，并且取出的数的和最大。</p>
<p>输入描述:</p>
<blockquote><p>每个测试实例包括一个整数n 和n∗n个非负整数，保证每个数不超过。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>3<br>75 15 21<br>75 15 28<br>34 70 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>188</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=16，每个数不超过 10^3。</p>
</blockquote>

<figure class="highlight c"><figcaption><span>fanggequshu.cpp</span><a href="/downloads/code/fanggequshu.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> mp[N][N], dp[N][<span class="number">70000</span>];</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">30005</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n;</span><br><span class="line">    <span class="keyword">while</span>(y){</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res += mp[x][j];</span><br><span class="line">        j--; y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++){</span><br><span class="line">        <span class="keyword">if</span>((i&amp;(i&gt;&gt;<span class="number">1</span>))==<span class="number">0</span>) A[++tot] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    dp[i][k] = max(dp[i][k], dp[i-1][j] + val(i-1, j))</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=tot;k++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++){</span><br><span class="line">                <span class="keyword">if</span>((A[j] &amp; A[k]) ==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">int</span> val = calc(i, A[k]);</span><br><span class="line">                    dp[i][k] = <span class="built_in">max</span>(dp[i][k], dp[i<span class="number">-1</span>][j] + val);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树网的核 (NOIP2007)</title>
    <url>/blog/%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/</url>
    <content><![CDATA[<p>设T=(V, E, W) 是一个无圈且连通的无向图（也称为无根树），每条边带有正整数的权，我们称T为树网（treenetwork），其中V, E分别表示结点与边的集合，W表示各边长度的集合，并设T有n个结点。<br>路径：树网中任何两结点a,b都存在唯一的一条简单路径，用d(a,b)表示以a,b为端点的路径的长度，它是该路径上各边长度之和。我们称d(a,b)为a,b两结点间的距离。<br>一点v到一条路径P的距离为该点与P上的最近的结点的距离：<br>d(v，P) = min{d(v，u)，u为路径P上的结点}。<br>树网的直径：树网中最长的路径称为树网的直径。对于给定的树网T，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。<br>偏心距ECC(F)：树网T中距路径F最远的结点到路径F的距离，即ECC(F)=min{d(v,F)，v∈V}。<br>任务：对于给定的树网T=(V, E,W)和非负整数s，求一个路径F，它是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过s（可以等于s），使偏心距ECC(F)最小。我们称这个路径为树网T=(V,E,W)的核（Core）。必要时，F可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。<br>下面的图给出了树网的一个实例。图中，A-B与A-C是两条直径，长度均为20。点W是树网的中心，EF边的长度为5。如果指定s=11，则树网的核为路径DEFG（也可以取为路径DEF），偏心距为8。如果指定s=0（或s=1、s=2），则树网的核为结点F，偏心距为12。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>第1行，两个正整数n和s，中间用一个空格隔开。其中n为树网结点的个数，s为树网的核的长度的上界。设结点编号依次为1, 2, …, n。<br>从第2行到第n行，每行给出3个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“2 4 7”表示连接结点2与4的边的长度为7。<br>所给的数据都是正确的，不必检验。</p>
</blockquote>

<p>输出描述:</p>
<blockquote><p>输出一个非负整数，为指定意义下的最小偏心距。</p>
</blockquote>

<p>示例1<br>输入</p>
<blockquote><p>5 2<br>1 2 5<br>2 3 2<br>2 4 4<br>2 5 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>示例2<br>输入</p>
<blockquote><p>8 6<br>1 3 2<br>2 3 2<br>3 4 6<br>4 5 3<br>4 6 4<br>4 7 2<br>7 8 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>备注：</p>
<blockquote><p>40%的数据满足：5 ≤ n ≤ 15<br>70%的数据满足：5 ≤ n ≤ 80<br>100%的数据满足：5 ≤ n ≤ 300, 0 ≤ s ≤ 1000。边长度为不超过1000的正整数</p>
</blockquote>

<figure class="highlight c"><figcaption><span>shuwangdehe.cpp</span><a href="/downloads/code/shuwangdehe.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, M = N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], idx, ne[M], w[M];</span><br><span class="line"><span class="keyword">int</span> q[N], st[N], dist[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>{</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> hh=<span class="number">0</span>, tt =<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = start;</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	dist[start] = <span class="number">0</span>;</span><br><span class="line">	st[start] = <span class="literal">true</span>;</span><br><span class="line">	pre[start] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt){</span><br><span class="line">		<span class="keyword">int</span> u= q[hh++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h[u]; ~i; i = ne[i]){</span><br><span class="line">			<span class="keyword">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span>(!st[j]){</span><br><span class="line">				st[j] = <span class="literal">true</span>;</span><br><span class="line">				dist[j] = dist[u] + w[i];</span><br><span class="line">				q[++tt] = j;</span><br><span class="line">				pre[j] = u;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">if</span>(dist[i] &gt; dist[t])</span><br><span class="line">			t = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs_max</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> hh=<span class="number">0</span>, tt=<span class="number">0</span>;</span><br><span class="line">	dist[u] = <span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = u;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt){</span><br><span class="line">		<span class="keyword">int</span> t= q[hh++];</span><br><span class="line">		res = <span class="built_in">max</span>(res, dist[t]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i]){</span><br><span class="line">			<span class="keyword">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span>(!st[j]){</span><br><span class="line">				st[j] = <span class="literal">true</span>;</span><br><span class="line">				dist[j] = dist[t] + w[i];</span><br><span class="line">				q[++tt] = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>, v = path.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(u+<span class="number">1</span>&lt;path.<span class="built_in">size</span>() &amp;&amp; path[u+<span class="number">1</span>].second &lt;= mid) u++;</span><br><span class="line">	<span class="keyword">while</span>(v<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; path.back().second - path[v<span class="number">-1</span>].second&lt;=mid) v--;</span><br><span class="line">	<span class="keyword">if</span>(u&gt;v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(path[v].second - path[u].second&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>();i++) st[path[i].first] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=u;i&lt;=v;i++)</span><br><span class="line">		<span class="keyword">if</span>(bfs_max(path[i].first) &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">// freopen("data.in", "r", stdin);</span></span><br><span class="line">	<span class="comment">// freopen("data.out", "w", stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		add(a, b, c), add(b, a, c);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	bfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> p = get_max();</span><br><span class="line">	bfs(p);</span><br><span class="line">	<span class="keyword">int</span> v = get_max();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(v!=<span class="number">-1</span>){</span><br><span class="line">		path.push_back(make_pair(v, dist[v]));</span><br><span class="line">		v = pre[v];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	reverse(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// for(int i=0;i&lt;path.size();i++)</span></span><br><span class="line">	<span class="comment">// 	printf("%d ", path[i].first);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r){</span><br><span class="line">		<span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>机器翻译 (NOIP2010)</title>
    <url>/blog/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。</p>
<p>这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。</p>
<p>假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M−1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。</p>
<p>假设一篇英语文章的长度为N 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>输入共2 行。每行中两个数之间用一个空格隔开。<br>第一行为两个正整数M 和N，代表内存容量和文章的长度。<br>第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>共1 行，包含一个整数，为软件需要查词典的次数。</p>
</blockquote>

<p>示例1<br>输入</p>
<blockquote><p>3 7<br>1 2 1 5 4 4 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>说明</p>
<blockquote><p>整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：<br>空：内存初始状态为空。<br>1． 1：查找单词1 并调入内存。<br>2． 1 2：查找单词2 并调入内存。<br>3． 1 2：在内存中找到单词1。<br>4． 1 2 5：查找单词5 并调入内存。<br>5． 2 5 4：查找单词4 并调入内存替代单词1。<br>6． 2 5 4：在内存中找到单词4。<br>7． 5 4 1：查找单词1 并调入内存替代单词2。<br>共计查了5次词典。</p>
</blockquote>

<p>备注：</p>
<blockquote><p>对于10%的数据有M=1，N ≤5。<br>对于100%的数据有0</p>
</blockquote>


<figure class="highlight c"><figcaption><span>jiqifanyi.cpp</span><a href="/downloads/code/jiqifanyi.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (!st[x])</span><br><span class="line">        {</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() == m)</span><br><span class="line">            {</span><br><span class="line">                st[q.front()] = <span class="literal">false</span>;</span><br><span class="line">                q.pop();</span><br><span class="line">            }</span><br><span class="line">            q.push(x);</span><br><span class="line">            st[x] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>simulation</tag>
      </tags>
  </entry>
</search>
