<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Quick Sort Template</title>
    <url>/blog/hello-world/</url>
    <content><![CDATA[<p>Quick sort is one of the most fundamental algorithms.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo s -p 8001</span><br></pre></td></tr></table></figure>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h3><figure class="highlight c"><figcaption><span>quick_sort.cpp</span><a href="/downloads/code/quick_sort.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = q[l], i=l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j){</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q[i], q[j]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    quick_sort(q, l ,j);</span><br><span class="line">    quick_sort(q, j+<span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>树网的核</title>
    <url>/blog/%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/</url>
    <content><![CDATA[<p>设T=(V, E, W) 是一个无圈且连通的无向图（也称为无根树），每条边带有正整数的权，我们称T为树网（treenetwork），其中V, E分别表示结点与边的集合，W表示各边长度的集合，并设T有n个结点。<br>路径：树网中任何两结点a,b都存在唯一的一条简单路径，用d(a,b)表示以a,b为端点的路径的长度，它是该路径上各边长度之和。我们称d(a,b)为a,b两结点间的距离。<br>一点v到一条路径P的距离为该点与P上的最近的结点的距离：<br>d(v，P) = min{d(v，u)，u为路径P上的结点}。<br>树网的直径：树网中最长的路径称为树网的直径。对于给定的树网T，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。<br>偏心距ECC(F)：树网T中距路径F最远的结点到路径F的距离，即ECC(F)=min{d(v,F)，v∈V}。<br>任务：对于给定的树网T=(V, E,W)和非负整数s，求一个路径F，它是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过s（可以等于s），使偏心距ECC(F)最小。我们称这个路径为树网T=(V,E,W)的核（Core）。必要时，F可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。<br>下面的图给出了树网的一个实例。图中，A-B与A-C是两条直径，长度均为20。点W是树网的中心，EF边的长度为5。如果指定s=11，则树网的核为路径DEFG（也可以取为路径DEF），偏心距为8。如果指定s=0（或s=1、s=2），则树网的核为结点F，偏心距为12。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>第1行，两个正整数n和s，中间用一个空格隔开。其中n为树网结点的个数，s为树网的核的长度的上界。设结点编号依次为1, 2, …, n。<br>从第2行到第n行，每行给出3个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“2 4 7”表示连接结点2与4的边的长度为7。<br>所给的数据都是正确的，不必检验。</p>
</blockquote>

<p>输出描述:</p>
<blockquote><p>输出一个非负整数，为指定意义下的最小偏心距。</p>
</blockquote>

<p>示例1<br>输入</p>
<blockquote><p>5 2<br>1 2 5<br>2 3 2<br>2 4 4<br>2 5 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>示例2<br>输入</p>
<blockquote><p>8 6<br>1 3 2<br>2 3 2<br>3 4 6<br>4 5 3<br>4 6 4<br>4 7 2<br>7 8 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>备注：</p>
<blockquote><p>40%的数据满足：5 ≤ n ≤ 15<br>70%的数据满足：5 ≤ n ≤ 80<br>100%的数据满足：5 ≤ n ≤ 300, 0 ≤ s ≤ 1000。边长度为不超过1000的正整数</p>
</blockquote>

<figure class="highlight c"><figcaption><span>shuwangdehe.cpp</span><a href="/downloads/code/shuwangdehe.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, M = N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], idx, ne[M], w[M];</span><br><span class="line"><span class="keyword">int</span> q[N], st[N], dist[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>{</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> hh=<span class="number">0</span>, tt =<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = start;</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	dist[start] = <span class="number">0</span>;</span><br><span class="line">	st[start] = <span class="literal">true</span>;</span><br><span class="line">	pre[start] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt){</span><br><span class="line">		<span class="keyword">int</span> u= q[hh++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h[u]; ~i; i = ne[i]){</span><br><span class="line">			<span class="keyword">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span>(!st[j]){</span><br><span class="line">				st[j] = <span class="literal">true</span>;</span><br><span class="line">				dist[j] = dist[u] + w[i];</span><br><span class="line">				q[++tt] = j;</span><br><span class="line">				pre[j] = u;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">if</span>(dist[i] &gt; dist[t])</span><br><span class="line">			t = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs_max</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> hh=<span class="number">0</span>, tt=<span class="number">0</span>;</span><br><span class="line">	dist[u] = <span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = u;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt){</span><br><span class="line">		<span class="keyword">int</span> t= q[hh++];</span><br><span class="line">		res = <span class="built_in">max</span>(res, dist[t]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i]){</span><br><span class="line">			<span class="keyword">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span>(!st[j]){</span><br><span class="line">				st[j] = <span class="literal">true</span>;</span><br><span class="line">				dist[j] = dist[t] + w[i];</span><br><span class="line">				q[++tt] = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>, v = path.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(u+<span class="number">1</span>&lt;path.<span class="built_in">size</span>() &amp;&amp; path[u+<span class="number">1</span>].second &lt;= mid) u++;</span><br><span class="line">	<span class="keyword">while</span>(v<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; path.back().second - path[v<span class="number">-1</span>].second&lt;=mid) v--;</span><br><span class="line">	<span class="keyword">if</span>(u&gt;v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(path[v].second - path[u].second&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>();i++) st[path[i].first] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=u;i&lt;=v;i++)</span><br><span class="line">		<span class="keyword">if</span>(bfs_max(path[i].first) &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">// freopen("data.in", "r", stdin);</span></span><br><span class="line">	<span class="comment">// freopen("data.out", "w", stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		add(a, b, c), add(b, a, c);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	bfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> p = get_max();</span><br><span class="line">	bfs(p);</span><br><span class="line">	<span class="keyword">int</span> v = get_max();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(v!=<span class="number">-1</span>){</span><br><span class="line">		path.push_back(make_pair(v, dist[v]));</span><br><span class="line">		v = pre[v];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	reverse(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// for(int i=0;i&lt;path.size();i++)</span></span><br><span class="line">	<span class="comment">// 	printf("%d ", path[i].first);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r){</span><br><span class="line">		<span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>机器翻译</title>
    <url>/blog/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。</p>
<p>这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。</p>
<p>假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M−1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。</p>
<p>假设一篇英语文章的长度为N 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>输入共2 行。每行中两个数之间用一个空格隔开。<br>第一行为两个正整数M 和N，代表内存容量和文章的长度。<br>第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>共1 行，包含一个整数，为软件需要查词典的次数。</p>
</blockquote>

<p>示例1<br>输入</p>
<blockquote><p>3 7<br>1 2 1 5 4 4 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>说明</p>
<blockquote><p>整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：<br>空：内存初始状态为空。<br>1． 1：查找单词1 并调入内存。<br>2． 1 2：查找单词2 并调入内存。<br>3． 1 2：在内存中找到单词1。<br>4． 1 2 5：查找单词5 并调入内存。<br>5． 2 5 4：查找单词4 并调入内存替代单词1。<br>6． 2 5 4：在内存中找到单词4。<br>7． 5 4 1：查找单词1 并调入内存替代单词2。<br>共计查了5次词典。</p>
</blockquote>

<p>备注：</p>
<blockquote><p>对于10%的数据有M=1，N ≤5。<br>对于100%的数据有0</p>
</blockquote>


<figure class="highlight c"><figcaption><span>jiqifanyi.cpp</span><a href="/downloads/code/jiqifanyi.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (!st[x])</span><br><span class="line">        {</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() == m)</span><br><span class="line">            {</span><br><span class="line">                st[q.front()] = <span class="literal">false</span>;</span><br><span class="line">                q.pop();</span><br><span class="line">            }</span><br><span class="line">            q.push(x);</span><br><span class="line">            st[x] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>simulation</tag>
      </tags>
  </entry>
</search>
