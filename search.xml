<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>昂贵的聘礼</title>
    <url>/blog/%E6%98%82%E8%B4%B5%E7%9A%84%E8%81%98%E7%A4%BC/</url>
    <content><![CDATA[<p>年轻的探险家来到了一个印第安部落里。在那里他和酋长的女儿相爱了，于是便向酋长去求亲。酋长要他用10000个金币作为聘礼才答应把女儿嫁给他。探险家拿不出这么多金币，便请求酋长降低要求。酋长说：”嗯，如果你能够替我弄到大祭司的皮袄，我可以只要8000金币。如果你能够弄来他的水晶球，那么只要5000金币就行了。”探险家就跑到大祭司那里，向他要求皮袄或水晶球，大祭司要他用金币来换，或者替他弄来其他的东西，他可以降低价格。探险家于是又跑到其他地方，其他人也提出了类似的要求，或者直接用金币换，或者找到其他东西就可以降低价格。不过探险家没必要用多样东西去换一样东西，因为不会得到更低的价格。探险家现在很需要你的帮忙，让他用最少的金币娶到自己的心上人。另外他要告诉你的是，在这个部落里，等级观念十分森严。地位差距超过一定限制的两个人之间不会进行任何形式的直接接触，包括交易。他是一个外来人，所以可以不受这些限制。但是如果他和某个地位较低的人进行了交易，地位较高的的人不会再和他交易，他们认为这样等于是间接接触，反过来也一样。因此你需要在考虑所有的情况以后给他提供一个最好的方案。<br>为了方便起见，我们把所有的物品从1开始进行编号，酋长的允诺也看作一个物品，并且编号总是1。每个物品都有对应的价格P，主人的地位等级L，以及一系列的替代品Ti和该替代品所对应的”优惠”Vi。如果两人地位等级差距超过了M，就不能”间接交易”。你必须根据这些数据来计算出探险家最少需要多少金币才能娶到酋长的女儿。</p>
<p>输入描述:</p>
<blockquote><p>输入第一行是两个整数M，N，依次表示地位等级差距限制和物品的总数。接下来按照编号从小到大依次给出了N个物品的描述。每个物品的描述开头是三个非负整数P、L、X（X &lt; N），依次表示该物品的价格、主人的地位等级和替代品总数。接下来X行每行包括两个整数T和V，分别表示替代品的编号和”优惠价格”。对于100%的数据，N∈[1,100],M∈[1,100].</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出最少需要的金币数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>1 4<br>10000 3 2<br>2 8000<br>3 5000<br>1000 2 1<br>4 200<br>3000 2 1<br>4 200<br>50 2 0</p>
</blockquote>

<p>输出</p>
<blockquote><p>5250</p>
</blockquote>



<figure class="highlight c"><figcaption><span>angguipinli.cpp</span><a href="/downloads/code/angguipinli.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> level[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, v;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;A) <span class="keyword">const</span>{ <span class="comment">//小根堆</span></span><br><span class="line">        <span class="keyword">return</span> v &gt; A.v;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[N];</span><br><span class="line">priority_queue&lt;Node&gt; Q;</span><br><span class="line"><span class="keyword">int</span> dis[N], st[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Node in Q is different from node used in input. Q stores (index, dis[index])</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijstra</span><span class="params">(<span class="keyword">int</span> L)</span></span>{ <span class="comment">//[L, L+m]</span></span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.push({<span class="number">0</span>, <span class="number">0</span>});</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()){</span><br><span class="line">        Node tmp = Q.top();Q.pop();</span><br><span class="line">        <span class="keyword">int</span> k = tmp.to;</span><br><span class="line">        <span class="keyword">if</span>(st[k]) <span class="keyword">continue</span>;</span><br><span class="line">        st[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[k].<span class="built_in">size</span>();i++){</span><br><span class="line">            <span class="keyword">int</span> y = edges[k][i].to;</span><br><span class="line">            <span class="keyword">int</span> v = edges[k][i].v;</span><br><span class="line">            <span class="keyword">if</span>(level[y]&lt;L || level[y] &gt; L+m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(dis[y] &gt; dis[k] + v){</span><br><span class="line">                dis[y] = dis[k] + v;</span><br><span class="line">                Q.push({y, dis[y]});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, dis[<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> x, k, y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){ <span class="comment">//该物品编号为i</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;level[i], &amp;k);</span><br><span class="line">        edges[<span class="number">0</span>].push_back({i, x}); <span class="comment">//编号， 价格</span></span><br><span class="line">        <span class="keyword">while</span>(k--){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;y, &amp;x);</span><br><span class="line">            edges[y].push_back({i, x}); <span class="comment">// 替代品x到target i插入价格为y的边</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++){</span><br><span class="line">        Dijstra(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>graph</tag>
        <tag>dijstra</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分</title>
    <url>/blog/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>两次dfs， 第一次求出son[x], 即重儿子的编号； 第二次求出top[x], 即x所在重链的根<br>结论， 每个点最多跳logn条重链，就可以到达树的根</p>
<p>用树链剖分可以求LCA</p>
<p>输入描述:</p>
<blockquote><p>n代表点的个数<br>n-1条边</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>i, son[i], top[i]</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>14 1<br>1 2<br>1 3<br>1 4<br>2 5<br>2 6<br>6 11<br>6 12<br>3 7<br>4 8<br>4 9<br>4 10<br>9 13<br>13 14<br>8 14 // m</p>
</blockquote>

<p>输出</p>
<blockquote><p>1 4 1<br>2 6 2<br>3 7 3<br>4 9 1<br>5 0 5<br>6 11 2<br>7 0 3<br>8 0 8<br>9 13 1<br>10 0 10<br>11 0 2<br>12 0 12<br>13 14 1<br>14 0 1<br>4</p>
</blockquote>


<img src="/downloads/imgs/shulian.png" class="example" title="title exg" alt="alt exg">

<figure class="highlight c"><figcaption><span>shulian.cpp</span><a href="/downloads/code/shulian.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N], dep[N], son[N], top[N], sz[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get son vector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x] = f, dep[x] = d, sz[x] = <span class="number">1</span>, son[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x, d+<span class="number">1</span>);</span><br><span class="line">        sz[x] += sz[y];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[x]] &lt; sz[y]) son[x] = y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// get top vector</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> tp)</span></span>{</span><br><span class="line">    top[x] = tp;</span><br><span class="line">    <span class="keyword">if</span>(son[x]) dfs2(son[x], x, tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs2(y, x, y);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// a和b走向一条重链</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(top[a]!=top[b]){</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]] &gt; dep[top[b]]){</span><br><span class="line">            a = fa[top[a]];</span><br><span class="line">        }<span class="keyword">else</span> b = fa[top[b]];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dep[a] &gt; dep[b] ? b: a;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, i, son[i], top[i]);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 8 jumps to 8, fa[8] = 4Œ</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LCA(a, b));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>动态差分</title>
    <url>/blog/%E5%8A%A8%E6%80%81%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<p>有n个点的一棵树，有m个操作，分为两类：<br>(1):1 x y d:把x到y路径上每个点的权值加d<br>(2):2 x:询问x点的权值</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m<br>接下来n-1行，每行两个整数，表示一条边<br>接下来m行，每行两个操作中的一个。<br>n,m&lt;=10^5</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个2操作，输出结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 4<br>1 2<br>1 3<br>3 4<br>3 5<br>1 3 4 1<br>2 3<br>1 1 5 2<br>2 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>3</p>
</blockquote>

<p>说明</p>
<blockquote><p>区别：动态回答询问</p>
</blockquote>


<figure class="highlight c"><figcaption><span>dongtaichafen.cpp</span><a href="/downloads/code/dongtaichafen.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每次修改路径，而非一个点, 区别于苹果树，同于找路径</span></span><br><span class="line"><span class="comment">// 要求动态回答询问， 区别于松鼠的新家，路径更新</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Two mistakes from LCA, (1) fa[N][S+2], (2) return after goUp.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">2</span>], dep[N];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Lid[N], Rid[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, id;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    Lid[x] = ++tot;</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f]+ <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f)<span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    }</span><br><span class="line">    Rid[x] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[a] &lt; dep[b]) swap(a,b);</span><br><span class="line">    goUp(a, dep[a]-dep[b]);</span><br><span class="line">    <span class="keyword">if</span>(a==b ) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[a][i] != fa[b][i])</span><br><span class="line">            a = fa[a][i], b= fa[b][i];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span>{</span></span><br><span class="line">    LL C[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=tot){</span><br><span class="line">            C[x] += d;</span><br><span class="line">            x += x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function">LL <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x){</span><br><span class="line">            res += C[x];</span><br><span class="line">            x -= x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}<span class="built_in">bit</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n ,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back({b, i});</span><br><span class="line">        edges[b].push_back({a, i});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x, y, d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x ,&amp;y, &amp;d);</span><br><span class="line">            <span class="keyword">int</span> c = lca(x, y);</span><br><span class="line"><span class="comment">//            printf("lca = %d %d %d\n", x, y, c);</span></span><br><span class="line">            <span class="keyword">int</span> e = fa[c][<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">bit</span>.add(Lid[x], d);</span><br><span class="line">            <span class="built_in">bit</span>.add(Lid[y], d);</span><br><span class="line">            <span class="built_in">bit</span>.add(Lid[c], -d);</span><br><span class="line">            <span class="keyword">if</span>(e)<span class="built_in">bit</span>.add(Lid[e], -d); <span class="comment">// if is crucial!</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, <span class="built_in">bit</span>.sum(Rid[x]) - <span class="built_in">bit</span>.sum(Lid[x] <span class="number">-1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>路径更新</title>
    <url>/blog/%E8%B7%AF%E5%BE%84%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>给出一棵 n 个结点的树，有m个操作，每次把一条路径上每条边都加上1，最后按照每条边的输入顺序，输出每个条被增加的次数。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m<br>接下来n-1行，每行两个整数，表示一条边<br>接下来m行，每行两个整数a和b，表示把a到b的路径上每条边都加1。<br>n, m&lt;=10^5</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>按照边输入的顺序，输出每条边被增加的次数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 3<br>1 2<br>1 3<br>3 4<br>3 5<br>1 4<br>1 5<br>2 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>3<br>1<br>1</p>
</blockquote>


<figure class="highlight c"><figcaption><span>lujinggengxin.cpp</span><a href="/downloads/code/lujinggengxin.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="keyword">int</span> ans[N], ID[N]; <span class="comment">//map node id to edge id</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, id;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], dep[N];</span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f] +<span class="number">1</span>, dis[x] = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        ID[y] = edges[x][i].id;  <span class="comment">// ID maps y to edge id;</span></span><br><span class="line">        dfs(y, x, d + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line"><span class="comment">//  starts from 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    goUp(x, dep[x]-dep[y]);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x; <span class="comment">// easy to forget</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y= fa[y][i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(y, x);</span><br><span class="line">        cnt[x] += cnt[y];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// crucial</span></span><br><span class="line">    ans[ID[x]] = cnt[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back({b, i});</span><br><span class="line">        edges[b].push_back({a, i});</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> c = lca(a, b);</span><br><span class="line">        cnt[a]++, cnt[b]++, cnt[c]-=<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>chafen</tag>
      </tags>
  </entry>
  <entry>
    <title>松鼠的新家</title>
    <url>/blog/%E6%9D%BE%E9%BC%A0%E7%9A%84%E6%96%B0%E5%AE%B6/</url>
    <content><![CDATA[<p>松鼠的新家是一棵树，前几天刚刚装修了新家，新家有n个房间，并且有n-1根树枝连接，每个房间都可以相互到达，且俩个房间之间的路线都是唯一的。天哪，他居然真的住在“树”上。松鼠想邀请小熊维尼前来参观，并且还指定一份参观指南，他希望维尼能够按照他的指南顺序，先去a_1，再去a_2，……，最后到a_n，去参观新家。</p>
<p>可是这样会导致维尼重复走很多房间，懒惰的维尼不听地推辞。可是松鼠告诉他，每走到一个房间，他就可以从房间拿一块糖果吃。维尼是个馋家伙，立马就答应了。</p>
<p>现在松鼠希望知道为了保证维尼有糖果吃，他需要在每一个房间各放至少多少个糖果。因为松鼠参观指南上的最后一个房间an是餐厅，餐厅里他准备了丰盛的大餐，所以当维尼在参观的最后到达餐厅时就不需要再拿糖果吃了。</p>
<p>输入描述:</p>
<blockquote><p>第一行一个整数n，表示房间个数 2&lt;=n&lt;=300000;</p>
<p>第二行n个整数，依次描述 a1~an。</p>
<p>接下来n-1行，每行两个整数x，y，表示标号x和y的两个房间之间有树枝相连。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>一共n行，第i行输出标号为i的房间至少需要放多少个糖果，才能让维尼有糖果吃。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5<br>1 4 5 3 2<br>1 2<br>2 4<br>2 3<br>4 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>2<br>1<br>2<br>1</p>
</blockquote>

<p>说明</p>
<blockquote><p>有n个点的一棵树， 沿着a1~an顺序去访问每个点， 路径上经过的点都要被加上一次，最后输出每个点被加的次数。</p>
</blockquote>


<figure class="highlight c"><figcaption><span>songshuhome.cpp</span><a href="/downloads/code/songshuhome.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[N], dep[N];</span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f] +<span class="number">1</span>, dis[x] = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x, d + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line"><span class="comment">//  starts from 0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);</span><br><span class="line">    goUp(x, dep[x]-dep[y]);</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> x; <span class="comment">// easy to forget</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i] != fa[y][i])</span><br><span class="line">            x = fa[x][i], y= fa[y][i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(y, x);</span><br><span class="line">        cnt[x] += cnt[y];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;path[i]);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) printf("%d ", fa[i][0]);</span></span><br><span class="line"><span class="comment">//    puts("");</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        a = path[i], b = path[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> c = lca(a, b);</span><br><span class="line"><span class="comment">//        printf("%d %d %d\n", a, b, c);</span></span><br><span class="line">        cnt[a]++, cnt[b]++, cnt[c]--, cnt[fa[c][<span class="number">0</span>]]--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) cnt[path[i]]--; <span class="comment">//why?</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>chafen</tag>
      </tags>
  </entry>
  <entry>
    <title>树上两点距离</title>
    <url>/blog/%E6%A0%91%E4%B8%8A%E4%B8%A4%E7%82%B9%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>给定一棵树，求树上两点间的距离。<br>输入描述:</p>
<blockquote><p>第一行两个整数n和m，表示点的个数和询问个数。<br>接下来n-1行，每行三个整数a，b，c，表示a和b有长度为c的边连接。<br>接下来m行，表示有m个询问，a和b，输出a和b的距离。<br>n和m的范围10^5;  边的长度不超过10^4.</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问输出相应的结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 4<br>1 2 1<br>1 3 2<br>2 4 3<br>2 5 4<br>1 2<br>2 3<br>4 5<br>3 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>3<br>7<br>6</p>
</blockquote>


<figure class="highlight c"><figcaption><span>shuliangdian.cpp</span><a href="/downloads/code/shuliangdian.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, S = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[N][S+<span class="number">2</span>]; <span class="comment">//crucial!</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> {</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edges[N];</span><br><span class="line"><span class="keyword">int</span> dep[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//f can't be -1, because of dep[f];</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span>{</span><br><span class="line">    fa[x][<span class="number">0</span>] = f, dep[x] = dep[f] + <span class="number">1</span>, dis[x] = d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> j = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(j==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(j, x, d + edges[x][i].val);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goUp</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> <span class="built_in">step</span>)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=S;i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)) x = fa[x][i];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dep[a]&lt;dep[b]) swap(a, b);</span><br><span class="line">    goUp(a, dep[a] - dep[b]);</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        <span class="keyword">if</span>(fa[a][i] != fa[b][i]){</span><br><span class="line">            a = fa[a][i];  b = fa[b][i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[a].push_back((Node){b, c});</span><br><span class="line">        edges[b].push_back((Node){a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=S;j++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            fa[i][j] = fa[ fa[i][j<span class="number">-1</span>] ][j<span class="number">-1</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">int</span> c = LCA(a, b);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[a] + dis[b] - <span class="number">2</span>*dis[c]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>找路径</title>
    <url>/blog/%E6%89%BE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<p>给定一棵含有n个节点的树，每个点上都有一个权值，有m个操作属于以下两种之一：</p>
<p>0 x y: 把x点的权值改为y</p>
<p>1 x: 询问从0出发，经过x的路径，最大和是多少？</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m<br>接下来n-1，每行两个整数，表示树上的一条边。<br>接下一行n个整数，表示每个节点上的权值v。<br>接下来m行，每行表示一个询问。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问，输出一个整数</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6 5<br>0 1<br>1 2<br>0 3<br>3 4<br>5 3<br>7 -5 100 20 -5 -7<br>1 1<br>1 3<br>0 2 -1<br>1 1<br>1 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>102<br>27<br>2<br>20</p>
</blockquote>


<figure class="highlight c"><figcaption><span>zhaolujing.cpp</span><a href="/downloads/code/zhaolujing.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[N];</span><br><span class="line"><span class="keyword">int</span> val[N]; <span class="comment">// number on this node</span></span><br><span class="line"><span class="keyword">int</span> Lid[N], Rid[N], tot;</span><br><span class="line"><span class="keyword">int</span> Line[N]; <span class="comment">//map from dfs_id to original id</span></span><br><span class="line">LL dis[N]; <span class="comment">// accumulated number from root till this node</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, LL d)</span></span>{</span><br><span class="line">    Lid[x] = ++tot; dis[x] = d; Line[tot] = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> j = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(j==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(j, x, d + val[j]);</span><br><span class="line">    }</span><br><span class="line">    Rid[x] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    LL mx, add;</span><br><span class="line">}tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].mx = <span class="built_in">max</span>(tree[p&lt;&lt;<span class="number">1</span>].mx, tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].L = L, tree[p].R = R;</span><br><span class="line">    tree[p].add = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L==R){</span><br><span class="line">        tree[p].mx = dis[Line[L]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = (L + R )&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    LL &amp;t = tree[p].add;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].add += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].mx += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].add += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].mx += t;</span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L == L &amp;&amp; tree[p].R ==R){</span><br><span class="line">        tree[p].add += x;</span><br><span class="line">        tree[p].mx += x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[p].L + tree[p].R )&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        update(L, mid, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        update(mid+<span class="number">1</span>, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L == L &amp;&amp; tree[p].R ==R ){</span><br><span class="line">        <span class="keyword">return</span> tree[p].mx;</span><br><span class="line">    }</span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = (tree[p].L + tree[p].R) &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(L,R, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(query(L, mid, p&lt;&lt;<span class="number">1</span>), query(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) edges[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back(b);</span><br><span class="line">        edges[b].push_back(a);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;val[i]);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//  dfs order</span></span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>, val[<span class="number">0</span>]);</span><br><span class="line">    build(<span class="number">1</span>, tot, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">            update(Lid[b], Rid[b], c-val[b], <span class="number">1</span>); <span class="comment">// segment tree supports dfs_id manipulation</span></span><br><span class="line">            val[b] = c;  <span class="comment">// original id</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(Lid[b], Rid[b], <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>seg_tree</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>苹果树</title>
    <url>/blog/%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<p>在卡卡的房子外面，有一棵苹果树。每年的春天，树上总会结出很多的苹果。卡卡非常喜欢吃苹果，所以他一直都精心的呵护这棵苹果树。我们知道树是有很多分叉点的，苹果会长在枝条的分叉点上面，且不会有两个苹果结在一起。卡卡很想知道一个分叉点所代表的子树上所结的苹果的数目，以便研究苹果树哪些枝条的结果能力比较强。<br>卡卡所知道的是，每隔一些时间，某些分叉点上会结出一些苹果，但是卡卡所不知道的是，总会有一些调皮的小孩来树上摘走一些苹果。<br>于是我们定义两种操作：<br>C x 表示编号为x的分叉点的状态被改变(原来有苹果的话，就被摘掉，原来没有的话，就结出一个苹果)<br>Q x 查询编号为x的分叉点所代表的子树中有多少个苹果<br>我们假定一开始的时候，树上全都是苹果，也包括作为根结点的分叉1。</p>
<p>输入描述:</p>
<blockquote><p>第一行一个数N<br>接下来n-1行,每行2个数u,v,表示分叉点u和分叉点v是直接相连的。<br>再接下来一行一个数M表示询问数<br>接下来M行,表示询问,询问的格式如题目所述Q x或者C x<br>n,m不超过 10^5;</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个Q x的询问,请输出相应的结果,每行输出一个</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>3<br>1 2<br>1 3<br>3<br>Q 1<br>C 2<br>Q 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>3<br>2</p>
</blockquote>

<p>说明:</p>
<blockquote><p>给定一棵根节点为1，包含n个节点的树， 每个节点的初始值为1， m个操作属于以下几种：<br>1 x:反正x节点的状态， 1变0， 0变1<br>2 x:询问x对应子树中的和</p>
</blockquote>


<figure class="highlight c"><figcaption><span>pingguoshu.cpp</span><a href="/downloads/code/pingguoshu.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> L[M], R[M], tot;</span><br><span class="line"><span class="keyword">int</span> val[M];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit</span>{</span></span><br><span class="line">    <span class="keyword">int</span> C[M];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> t)</span></span>{</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=n){</span><br><span class="line">            C[x] += t;</span><br><span class="line">            x += x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x){</span><br><span class="line">            res += C[x];</span><br><span class="line">            x -= x&amp;-x;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}<span class="built_in">bit</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    L[x] = ++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i];</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">    }</span><br><span class="line">    R[x] = tot;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edges[a].push_back({b});</span><br><span class="line">        edges[b].push_back({a});</span><br><span class="line">        <span class="built_in">bit</span>.add(i,<span class="number">1</span>);</span><br><span class="line">        val[i] = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    val[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bit</span>.add(n, <span class="number">1</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个点的新编号是L[x], 管理的区间是[L[x], R[x]]</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单点修改， 区间查询</span></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d"</span>, s, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'C'</span>) {</span><br><span class="line">            <span class="built_in">bit</span>.add(L[x], -val[x]);</span><br><span class="line">            val[x] = -val[x];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> m = <span class="built_in">bit</span>.sum(R[x]) - <span class="built_in">bit</span>.sum(L[x]<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>tree</tag>
        <tag>bit_tree</tag>
      </tags>
  </entry>
  <entry>
    <title>树的直径</title>
    <url>/blog/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<p>给定一棵树，求出这棵树的直径，即两个节点距离的最大值。</p>
<p>输入描述:</p>
<blockquote><p>输入第一行，一个整数n;<br>接下来n−1行，每行三个整数a,b,c，表示连接节点a和b的边长为c</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出这棵树的直径。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6<br>0 1 3<br>1 5 4<br>1 2 2<br>2 3 1<br>2 4 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>11</p>
</blockquote>

<p>说明</p>
<blockquote><p>csacademy.com/app/graph_editor</p>
</blockquote>


<figure class="highlight c"><figcaption><span>tree_radius1.cpp</span><a href="/downloads/code/tree_radius1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, R=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> dis)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(dis &gt; ans) {ans = dis, R = x;}</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x, dis + edges[x][i].val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[a].push_back({b,c});</span><br><span class="line">        edges[b].push_back({a,c});</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs(R, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>tree_radius2.cpp</span><a href="/downloads/code/tree_radius2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> fir = <span class="number">0</span>, sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edges[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edges[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t= dfs(y, x) + edges[x][i].val;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;fir){</span><br><span class="line">            sec = fir;</span><br><span class="line">            fir = t;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t &gt; sec)</span><br><span class="line">            sec = t;</span><br><span class="line">    }</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, fir+sec);</span><br><span class="line">    <span class="keyword">return</span> fir;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++){</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edges[a].push_back({b,c});</span><br><span class="line">        edges[b].push_back({a,c});</span><br><span class="line">    }</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表</title>
    <url>/blog/ST%E8%A1%A8/</url>
    <content><![CDATA[<p>有一个长度为n的数组A，有m个询问，每次你需要回答在区间[L,R]内的数的最大值。</p>
<p>输入描述:</p>
<blockquote><p>输入的第一行是两个整数n,m,表示数组长度和询问个数。<br>第二行n个元素，表示A数组。<br>接下来m行，每行两个整数L和R，表示一个区间。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问，输出相应的结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 3<br>4 5 2 3 8<br>3 4<br>3 5<br>2 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>3<br>8<br>5</p>
</blockquote>

<p>说明</p>
<blockquote><p>n,m&lt;=10^5</p>
</blockquote>


<figure class="highlight c"><figcaption><span>st1.cpp</span><a href="/downloads/code/st1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = a[L];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = R-L +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=<span class="built_in">step</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)){</span><br><span class="line">            res = <span class="built_in">max</span>(res, S[L][i]);</span><br><span class="line">            L += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        S[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) {</span><br><span class="line">            <span class="keyword">int</span> t = i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            S[i][j] = <span class="built_in">max</span>(S[i][j<span class="number">-1</span>], S[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>st2.cpp</span><a href="/downloads/code/st2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(L+(<span class="number">1</span>&lt;&lt;k)&lt;R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>) k++;</span><br><span class="line">    res = <span class="built_in">max</span>(S[L][k], S[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        S[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) {</span><br><span class="line">            <span class="keyword">int</span> t = i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            S[i][j] = <span class="built_in">max</span>(S[i][j<span class="number">-1</span>], S[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>st3.cpp</span><a href="/downloads/code/st3.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S[N][<span class="number">17</span>];</span><br><span class="line"><span class="keyword">int</span> Log[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k= Log[R-L+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">max</span>(S[L][k], S[R-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        S[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Log[<span class="number">0</span>] =<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Log[i] = Log[i&gt;&gt;<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++) {</span><br><span class="line">            <span class="keyword">int</span> t = i + (<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            S[i][j] = <span class="built_in">max</span>(S[i][j<span class="number">-1</span>], S[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>data_structure</tag>
        <tag>beizeng</tag>
      </tags>
  </entry>
  <entry>
    <title>MinMax</title>
    <url>/blog/MinMax/</url>
    <content><![CDATA[<img src="/downloads/imgs/minmax.png" class="example" title="title exg" alt="alt exg">

<p>输入描述:</p>
<blockquote><p>输入的第一行是两个整数n k。<br>接下来一行n个整数，表示数列a_i</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出两行，每行n-k+1个数，第一行是b数组，第二行是c数组。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>8 3<br>1 3 -1 -3 5 3 6 7</p>
</blockquote>

<p>输出</p>
<blockquote><p>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=10^6</p>
</blockquote>


<figure class="highlight c"><figcaption><span>minmax.cpp</span><a href="/downloads/code/minmax.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"><span class="keyword">int</span> tt=<span class="number">0</span>, rr = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; a[q[rr]]&gt;=a[i]) rr--;</span><br><span class="line">        q[++rr] = i;</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; i-q[tt]&gt;=k) tt++;</span><br><span class="line">        ans[i] = q[tt];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[ans[i]]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    tt =<span class="number">0</span>, rr = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; a[q[rr]]&lt;=a[i]) rr--;</span><br><span class="line">        q[++rr] = i;</span><br><span class="line">        <span class="keyword">while</span>(tt&lt;=rr &amp;&amp; i-q[tt]&gt;=k) tt++;</span><br><span class="line">        ans[i] = q[tt];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[ans[i]]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>monotone_queue</tag>
      </tags>
  </entry>
  <entry>
    <title>最大面积</title>
    <url>/blog/%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<p>现在有由n个宽度为1，高度分别为$h_1,h_2,…h_n$的长方形从左到右依次排列组成的柱形图。问里面包含的长方形的最大面积是多少？</p>
<p>输入描述:</p>
<blockquote><p>第一行一个整数n，表示柱形个数。<br>接下来一行n个整数，表示每个柱形的高度$h_i$。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出最大的矩形面积。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>7<br>2 1 4 5 1 3 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>8</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=10^5.</p>
</blockquote>


<figure class="highlight c"><figcaption><span>zuidamianji.cpp</span><a href="/downloads/code/zuidamianji.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> L[N], R[N];</span><br><span class="line"><span class="keyword">int</span> stk[N], t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;h[i]);</span><br><span class="line"></span><br><span class="line">    stk[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="keyword">while</span> (t &gt; <span class="number">0</span> &amp;&amp; h[stk[t]] &gt;= h[i]) t--;</span><br><span class="line">        L[i] = stk[t];</span><br><span class="line">        stk[++t] = i;</span><br><span class="line">    }</span><br><span class="line">    stk[<span class="number">0</span>] = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--){</span><br><span class="line">        <span class="keyword">while</span>(t&gt;<span class="number">0</span> &amp;&amp; h[stk[t]] &gt;= h[i]) t--;</span><br><span class="line">        R[i] = stk[t];</span><br><span class="line">        stk[++t] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) printf("%d ", L[i]);</span></span><br><span class="line"><span class="comment">//    puts("");</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) printf("%d ", R[i]);</span></span><br><span class="line"><span class="comment">//    puts("");</span></span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="number">1L</span>L * (R[i]-L[i] <span class="number">-1</span>) * h[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>monotone_stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Quick Sort Template</title>
    <url>/blog/hello-world/</url>
    <content><![CDATA[<p>Quick sort is one of the most fundamental algorithms.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo s -p 8001</span><br></pre></td></tr></table></figure>
<h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="quick-sort"><a href="#quick-sort" class="headerlink" title="quick sort"></a>quick sort</h3><figure class="highlight c"><figcaption><span>quick_sort.cpp</span><a href="/downloads/code/quick_sort.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> x = q[l], i=l<span class="number">-1</span>, j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j){</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) swap(q[i], q[j]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    quick_sort(q, l ,j);</span><br><span class="line">    quick_sort(q, j+<span class="number">1</span>, r);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">    quick_sort(q, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>template</category>
      </categories>
      <tags>
        <tag>basic_algo</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepSnake</title>
    <url>/blog/DeepSnake/</url>
    <content><![CDATA[<h2 id="Traditional-snake-algorithms"><a href="#Traditional-snake-algorithms" class="headerlink" title="Traditional snake algorithms:"></a>Traditional snake algorithms:</h2><blockquote><p>given an initial contour, traditional snake algorithms treat the coordinates<br>of the vertices as a set of variables and optimize an energy functional with respect to these variables.<br>Active contour models could optimize the contour to the object boundary. The energy functional is typically<br>nonconvex, the deformation process tend to find local optimal solutions.</p>
</blockquote>

<h2 id="Network-Architecture"><a href="#Network-Architecture" class="headerlink" title="Network Architecture:"></a>Network Architecture:</h2><blockquote><p>Deep snake consists of three parts: <span style="color:red">a backbone</span>, <span style="color:red">a fusion block</span> and <span style="color:red">a prediction head</span>. The backbone is comprised<br> of 8 “CirConvBn-ReLU” layers and <em>uses residual skip connections for all layers</em>. The fusion block aims to fuse<br> the information across all contour points at multiple scales.</p>
</blockquote>
<img src="/downloads/imgs/deepsnake_architecture.jpg" class="example" title="title exg" alt="alt exg">

<h2 id="Detail"><a href="#Detail" class="headerlink" title="Detail:"></a>Detail:</h2><blockquote><p>Add deep snake to an object detection model. The detector first produces objet boxes that are used to construct<br>diamond contours. Then deep snake deforms the diamond vertices to object extreme points, which are used to<br>construct octagon contours. Finally, the approach takes <strong>octagons as initial contours and performs iterative<br>contour deformation to obtain the object shape</strong>.</p>
</blockquote>

<h2 id="Initial-contour-proposal"><a href="#Initial-contour-proposal" class="headerlink" title="Initial contour proposal:"></a>Initial contour proposal:</h2><blockquote><p>The octagon is formed by four extreme points, which are top, leftmost, bottom, rightmost pixels in an object,<br>given a detected object box, extract four points centered at top, left, bottom, right box borders and then<br>connect them to get a diamond contour.</p>
</blockquote>

<h2 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization:"></a>Optimization:</h2><blockquote><p>Regressing the offsets in one pass in challenging, especially for vertices far away from the object. <strong>Use an<br>iterative optimization fashion</strong>. Solve the localization errors from the detector.</p>
</blockquote>

<h2 id="Multi-component-objects"><a href="#Multi-component-objects" class="headerlink" title="Multi-component objects:"></a>Multi-component objects:</h2><blockquote><p>use RoIAlign to extract a feature map and adds a detector branch on the feature map to produce the component boxes.</p>
</blockquote>

<img src="/downloads/imgs/RoIAlign.png" class="example" title="title exg" alt="alt exg">




]]></content>
      <categories>
        <category>Computer Vision</category>
      </categories>
      <tags>
        <tag>Instance Segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title>动态区间求和</title>
    <url>/blog/%E5%8A%A8%E6%80%81%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p>给定一个长度为n的序列，有m个操作，需要实现区间加一个值和统计区间和。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m，表示有一个长度为n个序列和m个操作。<br>第二行n个整数表示初始序列。<br>接下来m行，每行的内容属于以下一种：<br>Add x y a：把在区间[x,y]内的数都加上a（a∈[-10000,10000]）。<br>Query x y：求出区间[x,y]中所有数的和。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问输出相应的结果。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 5<br>1 2 3 4 5<br>Query 1 5<br>Add 1 3 5<br>Query 3 5<br>Add 3 5 10<br>Query 1 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>15<br>17<br>60</p>
</blockquote>

<p>说明</p>
<blockquote><p>n,m&lt;=10^5</p>
</blockquote>


<figure class="highlight c"><figcaption><span>lazy_seg_tree.cpp</span><a href="/downloads/code/lazy_seg_tree.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    LL tag, sum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">len</span><span class="params">()</span></span>{ <span class="keyword">return</span> (R-L+<span class="number">1</span>);}</span><br><span class="line"></span><br><span class="line">}tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].sum = tree[p&lt;&lt;<span class="number">1</span>].sum + tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].L = L, tree[p].R =R;</span><br><span class="line">    <span class="keyword">if</span>(L==R){</span><br><span class="line">        tree[p].sum = A[L];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    LL &amp;t = tree[p].tag;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].tag += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>].sum += t * tree[p&lt;&lt;<span class="number">1</span>].len();</span><br><span class="line"></span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tag += t;</span><br><span class="line">    tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum += t*tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空懒标记</span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L ==L &amp;&amp; tree[p].R ==R){</span><br><span class="line">        tree[p].tag += x;</span><br><span class="line">        tree[p].sum += tree[p].len() * x; <span class="comment">// forget;</span></span><br><span class="line">        <span class="comment">//forget</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    }</span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = tree[p].L + tree[p].R &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) update(L, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        update(L, mid, x, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        update(mid+<span class="number">1</span>, R, x, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    up(p);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L==L &amp;&amp; tree[p].R==R){</span><br><span class="line">        <span class="keyword">return</span> tree[p].sum;</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//    forget</span></span><br><span class="line">    down(p);</span><br><span class="line">    <span class="keyword">int</span> mid = tree[p].L + tree[p].R &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> query(L, mid, p&lt;&lt;<span class="number">1</span>) + query(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>){</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            update(a, b, c, <span class="number">1</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">int</span> a, b;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(a, b, <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>chunji_nowcoder</tag>
        <tag>lazy_tag</tag>
      </tags>
  </entry>
  <entry>
    <title>区间统计</title>
    <url>/blog/%E5%8C%BA%E9%97%B4%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<p>给定一个1到n的排列A数组，有m个询问，每次查询下标在[L,R]范围内，小于等于x的数的个数。</p>
<p>输入描述:</p>
<blockquote><p>第一行2个整数n和m。<br>第二行n个整数，表示一个排列。<br>接下来m行，每行3个整数L,R,x。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问，输出相应的结果</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 3<br>4 3 2 5 1<br>1 2 3<br>2 4 3<br>3 5 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>2<br>2</p>
</blockquote>

<p>说明</p>
<blockquote><p>n,m&lt;=10^5</p>
</blockquote>


<figure class="highlight c"><figcaption><span>qujiantongji_fenkuai.cpp</span><a href="/downloads/code/qujiantongji_fenkuai.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N], B[N];</span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ka = L / S, kb = R / S;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ka == kb) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) {</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; (ka + <span class="number">1</span>) * S; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ka + <span class="number">1</span>; i &lt; kb; i++) {</span><br><span class="line">            res += upper_bound(B + i * S, B + i * S + S, x) - (B + i * S);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = kb * S; i &lt;= R; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        B[i] = A[i];</span><br><span class="line">    }</span><br><span class="line">    S = <span class="built_in">sqrt</span>(n*<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=S;i+S<span class="number">-1</span>&lt;=n;i+=S){</span><br><span class="line">        sort(B+i, B+i+S);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> a, b, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">        <span class="keyword">int</span> ans = query(a, b, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>qujiantongji2.cpp</span><a href="/downloads/code/qujiantongji2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N], sum[<span class="number">320</span>][N];</span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> ka = L / S, kb = R / S;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ka == kb) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) {</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt; (ka + <span class="number">1</span>) * S; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ka + <span class="number">1</span>; i &lt; kb; i++) {</span><br><span class="line">            res += sum[i][x];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = kb * S; i &lt;= R; i++)</span><br><span class="line">            res += A[i] &lt;= x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    S = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        sum[i/S][A[i]] ++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/S; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            sum[i][j] += sum[i][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> a, b, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;x);</span><br><span class="line">        <span class="keyword">int</span> ans = query(a, b, x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>qujiantongji_fenwick_tree.cpp</span><a href="/downloads/code/qujiantongji_fenwick_tree.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> C[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> x, id, flag;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;query[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> a)</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(x&lt;=n){</span><br><span class="line">        C[x] += a;</span><br><span class="line">        x += x&amp;-x;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x){</span><br><span class="line">        res+= C[x];</span><br><span class="line">        x-= x&amp;-x;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pre[i] = pre[i<span class="number">-1</span>] + A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        C[i] = pre[i] - pre[i-(i&amp;-i)];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="keyword">int</span> L, R, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;L, &amp;R, &amp;x);</span><br><span class="line">        query[R].push_back((Node){x, i, <span class="number">1</span>});</span><br><span class="line">        query[L<span class="number">-1</span>].push_back((Node){x, i, <span class="number">-1</span>});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//    for(int i=1;i&lt;=n;i++) add(A[i], 1);  wrong</span></span><br><span class="line"><span class="comment">//  下标有序，按序点亮二进制值， 权值树状数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        add(A[i], <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;query[i].<span class="built_in">size</span>();j++){</span><br><span class="line">            ans[query[i][j].id] += query[i][j].flag * sum(query[i][j].x);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">//    离线回答询问,</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>data_structure</tag>
        <tag>fenwick_tree_offline</tag>
        <tag>seg_tree</tag>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title>最优贸易分块</title>
    <url>/blog/%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>C国有 n 座城市，编号是 1 到 n ，编号为 i 的城市有路到编号为 i+1 的城市（编号为 n 的城市没有路到其他的城市）。</p>
<p>C国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。</p>
<p>商人阿龙再次来到C国旅游。他还是想贩卖水晶赚取旅费，在某个城市买入，再另一个城市卖出。</p>
<p>他将从编号为 a 的城市到编号到 b 的城市。请你帮他算算，最多能赚多少钱。</p>
<p>注：他最多进行一次买入和一次卖出。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n和m，表示n个城市和m个询问。<br>第二行n个整数，表示n座城市水晶的买入和卖出的价格。<br>接下来m行，每行两个整数a,b，表示阿龙要从编号为a的城市到编号为b的城市（保证a&lt;b）。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每个询问输出阿龙最多能赚多少钱。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>6 3<br>2 1 3 6 4 5<br>1 2<br>2 4<br>1 6</p>
</blockquote>

<p>输出</p>
<blockquote><p>0<br>5<br>5</p>
</blockquote>

<p>说明</p>
<blockquote><p>从1到2，无法赚钱。<br>从2到4，在编号为2的城市买入，在编号为4的城市卖出。<br>从1到6，在编号为2的城市买入，在编号为4的城市卖出。</p>
</blockquote>


<figure class="highlight c"><figcaption><span>zuiyoumaoyi_fenkuai.cpp</span><a href="/downloads/code/zuiyoumaoyi_fenkuai.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">320</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> S;</span><br><span class="line"><span class="keyword">int</span> A[M];</span><br><span class="line"><span class="keyword">int</span> V[N], Mi[N], Mx[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ka = L/S, kb= R/S;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mi = A[L];</span><br><span class="line">    <span class="keyword">if</span>(ka==kb){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;=R;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, A[i] - mi);</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, A[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;(ka+<span class="number">1</span>)*S;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, A[i] - mi);</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, A[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=ka+<span class="number">1</span>;i&lt;kb;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(V[i], Mx[i] - mi));</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, Mi[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=kb*S;i&lt;=R;i++){</span><br><span class="line">            res = <span class="built_in">max</span>(res, A[i] - mi);</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, A[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    S = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n/S; i++){</span><br><span class="line">        V[i] = <span class="number">0</span>;</span><br><span class="line">        Mi[i] = <span class="number">1e9</span>;</span><br><span class="line">        Mx[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">int</span> x = i/S;</span><br><span class="line">        V[x] = <span class="built_in">max</span>(V[x], A[i] - Mi[x]);</span><br><span class="line">        Mi[x] = <span class="built_in">min</span>(Mi[x], A[i]);</span><br><span class="line">        Mx[x] = <span class="built_in">max</span>(Mx[x], A[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">int</span> ans = query(l, r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuiyoumaoyi_segtree.cpp</span><a href="/downloads/code/zuiyoumaoyi_segtree.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> val, mi, mx;</span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">}tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(Node&amp;root, Node &amp;ls, Node &amp;rs)</span></span>{</span><br><span class="line">    root.val = <span class="built_in">max</span>(<span class="built_in">max</span>(ls.val, rs.val), rs.mx-ls.mi);</span><br><span class="line">    root.mi = <span class="built_in">min</span>(ls.mi, rs.mi);</span><br><span class="line">    root.mx = <span class="built_in">max</span>(ls.mx, rs.mx);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    tree[p].L = L, tree[p].R = R;</span><br><span class="line">    <span class="keyword">if</span>(L==R){</span><br><span class="line">        tree[p].val = <span class="number">0</span>;</span><br><span class="line">        tree[p].mi = A[L];</span><br><span class="line">        tree[p].mx = A[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = L+R&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//递归完毕，用tree</span></span><br><span class="line">    up(tree[p], tree[p&lt;&lt;<span class="number">1</span>], tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> p)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(tree[p].L ==L &amp;&amp; tree[p].R==R){</span><br><span class="line">        <span class="keyword">return</span> tree[p];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> mid = tree[p].L + tree[p].R &gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;=mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L&gt;mid) <span class="keyword">return</span> query(L, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line"><span class="comment">//        准备开始递归</span></span><br><span class="line">        Node B = query(L, mid, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        Node C = query(mid+<span class="number">1</span>, R, p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">        Node res;</span><br><span class="line">        up(res, B, C);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n ,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">    build(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R, <span class="number">1</span>).val);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuiyoumaoyi_beizeng.cpp</span><a href="/downloads/code/zuiyoumaoyi_beizeng.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> V[N][<span class="number">17</span>], Mi[N][<span class="number">17</span>], Mx[N][<span class="number">17</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span> = R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, mi = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=<span class="built_in">step</span>;i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">step</span> &amp; (<span class="number">1</span>&lt;&lt;i)){</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(V[L][i], Mx[L][i] - mi));</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, Mi[L][i]);</span><br><span class="line">            L += (<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        V[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        Mi[i][<span class="number">0</span>] = A[i];</span><br><span class="line">        Mx[i][<span class="number">0</span>] = A[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=n;j++){</span><br><span class="line"><span class="comment">//      i starts from i cause'  A starts from 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n;i++){</span><br><span class="line">            <span class="keyword">int</span> t = i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>);</span><br><span class="line">            V[i][j] = <span class="built_in">max</span>(<span class="built_in">max</span>(V[i][j<span class="number">-1</span>], V[t][j<span class="number">-1</span>]), Mx[t][j<span class="number">-1</span>] - Mi[i][j<span class="number">-1</span>]);</span><br><span class="line">            Mx[i][j] = <span class="built_in">max</span>(Mx[i][j<span class="number">-1</span>], Mx[t][j<span class="number">-1</span>]);</span><br><span class="line">            Mi[i][j] = <span class="built_in">min</span>(Mi[i][j<span class="number">-1</span>], Mi[t][j<span class="number">-1</span>]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(L, R));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>zuiyoumaoyi_union_set.cpp</span><a href="/downloads/code/zuiyoumaoyi_union_set.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> A[N];</span><br><span class="line"><span class="keyword">int</span> fa[N];</span><br><span class="line"><span class="comment">// corresponding value from i to root</span></span><br><span class="line"><span class="keyword">int</span> V[N], Mx[N], Mi[N];</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> L, id;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;query[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getfa</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(fa[x] != x) {</span><br><span class="line">        <span class="keyword">int</span> t = fa[x];</span><br><span class="line">        <span class="comment">// finish calc of father's Mi[t], V[t], Mx[t]</span></span><br><span class="line">        fa[x] = getfa(t);</span><br><span class="line">        <span class="comment">// x--&gt; t --&gt; fa[x]</span></span><br><span class="line">        V[x] = <span class="built_in">max</span>(V[x], <span class="built_in">max</span>(V[t], Mx[t] - Mi[x]));</span><br><span class="line">        Mi[x] = <span class="built_in">min</span>(Mi[x], Mi[t]);</span><br><span class="line">        Mx[x] = <span class="built_in">max</span>(Mx[x], Mx[t]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> fa[x];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]);</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        Mi[i] = Mx[i] = A[i];</span><br><span class="line">        V[i] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="keyword">int</span> L, R;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;L, &amp;R);</span><br><span class="line">        query[R].push_back((Node){L, i});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;query[i].<span class="built_in">size</span>();j++){</span><br><span class="line">            <span class="keyword">int</span> L = query[i][j].L;  <span class="comment">//[L, i]</span></span><br><span class="line">            getfa(L);</span><br><span class="line">            ans[query[i][j].id] = V[L];</span><br><span class="line">        }</span><br><span class="line">        fa[i] = i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>data_structure</tag>
        <tag>seg_tree</tag>
        <tag>block</tag>
        <tag>beizeng</tag>
      </tags>
  </entry>
  <entry>
    <title>进电梯</title>
    <url>/blog/%E8%BF%9B%E7%94%B5%E6%A2%AF/</url>
    <content><![CDATA[<p>n个人在排成一队在电梯面前，最前面的人每一秒钟会进行一次选择，有p的概率进电梯，有1-p的概率停在原地。每个人只有他前面的人都进电梯了，他才有可能进电梯。求t秒之后，进电梯人数的期望值。</p>
<p>输入描述:</p>
<blockquote><p>一行三个数n t p（n,t是不超过2000的整数；p是浮点数，范围在[0,1]之间）。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>输出t秒钟后，电梯中人数的期望值。保留6位小数。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>1 1 0.50</p>
</blockquote>

<p>输出</p>
<blockquote><p>0.500000</p>
</blockquote>


<p>填表法：<br>dp[i][j] = dp[i-1][j] * (1-p) + dp[i-1][j-1] * p</p>
<p>刷表法：<br>dp[i+1][j] += dp[i][j] * (1-p)<br>dp[i+1][j+1] += dp[i][j] * p</p>
<figure class="highlight c"><figcaption><span>jindianti.cpp</span><a href="/downloads/code/jindianti.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">double</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"><span class="keyword">double</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;n, &amp;t, &amp;p);</span><br><span class="line"><span class="comment">//    cin&gt;&gt;n&gt;&gt;t&gt;&gt;p;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++){</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] * (<span class="number">1</span>-p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=(i,n<span class="number">-1</span>);j++) {</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] * (<span class="number">1</span>-p) + dp[i<span class="number">-1</span>][j<span class="number">-1</span>] * p;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=n) dp[i][n] = dp[i<span class="number">-1</span>][n] + dp[i<span class="number">-1</span>][n<span class="number">-1</span>] * p;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans += dp[t][i] * i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉苹果树</title>
    <url>/blog/%E4%BA%8C%E5%8F%89%E8%8B%B9%E6%9E%9C%E6%A0%91/</url>
    <content><![CDATA[<p>给定一棵n个结点的二叉树，你需要选择一棵以1号结点为根，m条边的联通子树，使得所选择的边权值之和最大。</p>
<p>输入描述:</p>
<blockquote><p>第一行两个整数n,m。<br>之后n-1行，每行三个整数x,y,z，表示结点x,y之间有一条权值为z的无向边。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>所选的边的权值和的最大值。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 2<br>1 3 1<br>1 4 10<br>2 3 20<br>3 5 20</p>
</blockquote>

<p>输出</p>
<blockquote><p>21</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=100, m&lt;=n-1.</p>
</blockquote>


<figure class="highlight c"><figcaption><span>erchapingguo1.cpp</span><a href="/downloads/code/erchapingguo1.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//70%</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y!=f){</span><br><span class="line">            dfs(y, x);</span><br><span class="line">            val[y] = edge[x][i].val;</span><br><span class="line">            ch[x][k++] = y;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//    printf("%d %d\n", x, k);</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> ls = ch[x][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> rs = ch[x][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(ls==<span class="number">0</span> &amp;&amp; rs==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++) dp[x][i] = val[x];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(ls!=<span class="number">0</span> &amp;&amp; rs!=<span class="number">0</span>) {</span><br><span class="line">        DP(ls);</span><br><span class="line">        DP(rs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt;= i; j++)</span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[ls][j] + dp[rs][i - j - <span class="number">1</span>] + val[x]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edge[a].push_back({b, c});</span><br><span class="line">        edge[b].push_back({a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    DP(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>erchapingguo2.cpp</span><a href="/downloads/code/erchapingguo2.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i].to;</span><br><span class="line">        <span class="keyword">if</span>(y!=f){</span><br><span class="line">            dfs(y, x);</span><br><span class="line">            val[y] = edge[x][i].val;</span><br><span class="line">            ch[x][k++] = y;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k!=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">int</span> ls = ch[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> rs = ch[x][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">                dp[x][i] = <span class="built_in">max</span>(dp[x][i], dp[ls][j] + dp[rs][i - j]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        dp[x][i] = dp[x][i<span class="number">-1</span>] + val[x];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edge[a].push_back({b, c});</span><br><span class="line">        edge[b].push_back({a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><figcaption><span>duochapingguo.cpp</span><a href="/downloads/code/duochapingguo.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// Note that m edges rather than m nodes.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>{</span></span><br><span class="line">    <span class="keyword">int</span> to, val;</span><br><span class="line">};</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="keyword">int</span> sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i].to, val = edge[x][i].val;</span><br><span class="line">        <span class="keyword">if</span> (y==f) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(y, x);</span><br><span class="line">        sz[x] += sz[y] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        <span class="keyword">int</span> mi= <span class="built_in">min</span>(sz[x], m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=mi;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">1</span>;t&lt;=j;t++) <span class="comment">// t个分给新儿子用,j-t给之前儿子用</span></span><br><span class="line">                tmp[j] = <span class="built_in">max</span>(tmp[j], dp[y][t<span class="number">-1</span>] + dp[x][j-t] + val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) dp[x][j] = <span class="built_in">max</span>(dp[x][j], tmp[j]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        edge[a].push_back((Node){b, c});</span><br><span class="line">        edge[b].push_back((Node){a, c});</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>没有上司的舞会</title>
    <url>/blog/%E6%B2%A1%E6%9C%89%E4%B8%8A%E5%8F%B8%E7%9A%84%E8%88%9E%E4%BC%9A/</url>
    <content><![CDATA[<p>有个公司要举行一场晚会。为了让到会的每个人不受他的直接上司约束而能玩得开心，公司领导决定：如果邀请了某个人，那么一定不会再邀请他的直接的上司，但该人的上司的上司，上司的上司的上司……都可以邀请。已知每个人最多有唯一的一个上司。<br>已知公司的每个人参加晚会都能为晚会增添一些气氛，求一个邀请方案，使气氛值的和最大。</p>
<p>输入描述:</p>
<blockquote><p>第1行一个整数N表示公司的人数，。<br>接下一行N个整数。第i行的数表示第i个人的气氛值x，。<br>接N-1下来每行两个整数K，L。表示第K个人是第L个人的上司。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>一个数，表示最大的气氛值和。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>4<br>1 7 3 4<br>1 2<br>2 3<br>2 4</p>
</blockquote>

<p>输出</p>
<blockquote><p>8</p>
</blockquote>

<p>说明</p>
<blockquote><p>你可以认为公司只有唯一的总boss，这个公司的关系图是一棵树。</p>
</blockquote>


<figure class="highlight c"><figcaption><span>wuhui.cpp</span><a href="/downloads/code/wuhui.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[N];</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[x].<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">int</span> y = edge[x][i];</span><br><span class="line">        dfs(y);</span><br><span class="line">        dp[x][<span class="number">1</span>] += dp[y][<span class="number">0</span>];</span><br><span class="line">        dp[x][<span class="number">0</span>] += <span class="built_in">max</span>(dp[y][<span class="number">0</span>], dp[y][<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dp[i][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        edge[a].push_back(b);</span><br><span class="line">        cnt[b]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!cnt[i]) {</span><br><span class="line">            t = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    dfs(t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">max</span>(dp[t][<span class="number">0</span>], dp[t][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑病毒</title>
    <url>/blog/%E7%94%B5%E8%84%91%E7%97%85%E6%AF%92/</url>
    <content><![CDATA[<p>假设你是一个黑客，入侵了一个有着n台计算机（编号为0,1,2,…n-1）的网络。一共有n种服务，每台计算机都运行着所有的服务。对于每台计算机，你都可以选择一项服务，终止这台计算机和所有与它相邻计算机的该项服务（如果其中一些服务已经停止，则这些服务继续处于停止状态）。你的目标是让尽可能多的服务瘫痪（即：没有任何计算机运行该项服务）。</p>
<p>输入描述:</p>
<blockquote><p>多组数据，以n=0结尾。<br>每组数据第一行包含一个整数n，n&lt;=16。<br>接下来，每行包括m+1个整数，其中第一个整数为m，表示受这台电脑服务的电脑台数；然后m个整数，表示这些电脑的编号。电脑的编号为0到n-1之间的整数。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>对于每组数据，输出完全瘫痪的服务的最大数量。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>3<br>2 1 2<br>2 0 2<br>2 0 1<br>4<br>1 1<br>1 0<br>1 3<br>1 2<br>0</p>
</blockquote>

<p>输出</p>
<blockquote><p>3<br>2</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=16</p>
</blockquote>


<figure class="highlight c"><figcaption><span>diannaobingdu.cpp</span><a href="/downloads/code/diannaobingdu.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> edge[N];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;N], arrive[<span class="number">1</span>&lt;&lt;N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), n!=<span class="number">0</span>){</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="built_in">memset</span>(arrive, <span class="number">0</span>, <span class="keyword">sizeof</span> arrive);</span><br><span class="line">        <span class="built_in">memset</span>(edge, <span class="number">0</span>, <span class="keyword">sizeof</span> edge);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">            edge[i]|=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">while</span>(m--)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">                edge[i]|= (<span class="number">1</span>&lt;&lt;x);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>) arrive[i] |= edge[j];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j;j=(j<span class="number">-1</span>)&amp;i){</span><br><span class="line">                <span class="keyword">if</span>(arrive[j] == (<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>)</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[i^j] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            dp[i] = ans;</span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>炮兵阵地</title>
    <url>/blog/%E7%82%AE%E5%85%B5%E9%98%B5%E5%9C%B0/</url>
    <content><![CDATA[<p>司令部的将军们打算在N<em>M的网格地图上部署他们的炮兵部队。一个N</em>M的地图由N行M列组成，地图的每一格可能是山地（用“H” 表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<img src="/downloads/imgs/paobing.png" class="example" width="500" height="500" title="title exg" alt="alt exg">
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。</p>
<p>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<p>输入描述:</p>
<blockquote><p>文件的第一行包含两个由空格分割开的正整数，分别表示N和M。<br>接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。</p>
</blockquote>

<p>输出描述:</p>
<blockquote><p>文件仅在第一行包含一个整数K，表示最多能摆放的炮兵部队的数量。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>5 4<br>PHPP<br>PPHH<br>PPPP<br>PHPP<br>PHHP</p>
</blockquote>

<p>输出</p>
<blockquote><p>6</p>
</blockquote>

<p>说明</p>
<blockquote><p>N&lt;=100, M&lt;=10.</p>
</blockquote>



<figure class="highlight c"><figcaption><span>paobingzhendi.cpp</span><a href="/downloads/code/paobingzhendi.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> S[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> ms[M];</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">100</span>], tot;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1025</span>];</span><br><span class="line"><span class="keyword">int</span> dp[N][<span class="number">1025</span>][<span class="number">1025</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, ms);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++){</span><br><span class="line">            S[i]|= (ms[j]==<span class="string">'H'</span>) &lt;&lt;j;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)</span><br><span class="line">        <span class="keyword">if</span>(!(i&amp;(i&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(i&amp;(i&lt;&lt;<span class="number">2</span>))) s[++tot] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">1</span>&lt;&lt;m;i++)</span><br><span class="line">        c[i]  = c[i-lowbit(i)] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++){</span><br><span class="line">            <span class="keyword">if</span>(s[i]&amp;S[x]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++){</span><br><span class="line">                <span class="keyword">if</span>(s[i] &amp; s[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[j] &amp; S[x<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=tot;k++){</span><br><span class="line">                    <span class="keyword">if</span>(s[i]&amp;s[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(s[j]&amp;s[k]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">2</span> &amp;&amp; s[k]&amp;S[x<span class="number">-2</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[x][i][j] = <span class="built_in">max</span>(dp[x][i][j], dp[x<span class="number">-1</span>][j][k] + c[s[i]]);</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, dp[x][i][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>愤怒的小鸟 (NOIP2016)</title>
    <url>/blog/%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/</url>
    <content><![CDATA[<p>Kiana 最近沉迷于一款神奇的游戏无法自拔。<br>简单来说，这款游戏是在一个平面上进行的。有一架弹弓位于 (0, 0) 处，每次 Kiana 可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 y = ax2 + bx 的曲线，其中 a，b 是 Kiana 指定的参数，且必须满足 a &lt; 0。当小鸟落回地面（即 x 轴）时，它就会瞬间消失。<br>在游戏的某个关卡里，平面的第一象限中有 n 只猪，其中第 i 只猪所在的坐标为 (xi, yi)。如果某只小鸟的飞行轨迹经过了(xi, yi)，那么第 i 只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；如果一只小鸟的飞行轨迹没有经过(xi, yi)，那么这只小鸟飞行的全过程就不会对第 i 只猪产生任何影响。<br>例如，若两只猪分别位于 (1, 3) 和 (3, 3)，Kiana 可以选择发射一只飞行轨迹为 y = -x2 + 4x 的小鸟，这样两只猪就会被这只小鸟一起消灭。<br>而这个游戏的目的，就是通过发射小鸟消灭所有的猪。<br>这款神奇游戏的每个关卡对来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在「输入描述」中详述。<br>假设这款游戏一共有 T 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>第一行包含一个正整数 T，表示游戏的关卡总数。<br>下面依次输入这 T 个关卡的信息。每个关卡第一行包含两个非负整数 n，m，分别表示该关卡中的猪数量和 Kiana 输入的神秘指令类型。<br>接下来的 n 行中，第 i 行包含两个正实数 (xi, yi)，表示第 i 只猪坐标为 (xi, yi)。数据保证同一个关卡中不存在两只坐标完全相同的猪。</p>
<p>保证 1 ≤ n ≤ 18，0 ≤ m ≤ 2，0 &lt; xi, yi &lt; 10，输入中的实数均保留到小数点后两位。</p>
</blockquote>

<p>输出描述</p>
<blockquote><p>对每个关卡依次输出一行答案。<br>输出的每一行包含一个正整数，表示相应的关卡中，消灭所有猪最少需要的小鸟数量。</p>
</blockquote>


<p>示例1<br>输入</p>
<blockquote><p>2<br>2 0<br>1.00 3.00<br>3.00 3.00<br>5 2<br>1.00 5.00<br>2.00 8.00<br>3.00 9.00<br>4.00 8.00<br>5.00 5.00</p>
</blockquote>

<p>输出</p>
<blockquote><p>1<br>1</p>
</blockquote>

<p>说明</p>
<blockquote><p>这组数据中一共有两个关卡。<br>第一个关卡与「题目描述」中的情形相同，2 只猪分别位于 (1.00, 3.00) 和 (3.00, 3.00)，只需发射一只飞行轨迹为 y = -x2 + 4x 的小鸟即可消灭它们。<br>第二个关卡中有 5 只猪，但经过观察我们可以发现它们的坐标都在抛物线 y = -x2 + 6x 上，故 Kiana 只需要发射一只小鸟即可消灭所有猪。</p>
</blockquote>

<figure class="highlight c"><figcaption><span>fennudexiaoniao.cpp</span><a href="/downloads/code/fennudexiaoniao.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">double</span>, <span class="keyword">double</span>&gt; PDD;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>, M = <span class="number">1</span>&lt;&lt;N;</span><br><span class="line">PDD q[N];</span><br><span class="line"><span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> path[N][N];</span><br><span class="line"><span class="keyword">int</span> f[M];</span><br><span class="line"><span class="keyword">int</span> lb[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x-y)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;q[i].x, &amp;q[i].y);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+<span class="number">1</span>&lt;<span class="number">1</span>&lt;&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                <span class="keyword">if</span>(!(i&gt;&gt;j&amp;<span class="number">1</span>)){</span><br><span class="line">                    lb[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">        <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span> path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) {</span><br><span class="line">            path[i][i] = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (!cmp(q[i].x, q[j].x)) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">double</span> x1 = q[i].x, y1 = q[i].y, x2 = q[j].x, y2 = q[j].y;</span><br><span class="line">                <span class="keyword">double</span> b = (y1 * x2 * x2 / x1 / x1 - y2) / (x2 * x2 / x1 - x2);</span><br><span class="line">                <span class="keyword">double</span> a = (y1 - b * x1) / x1 / x1;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) {</span><br><span class="line">                    <span class="keyword">double</span> x = q[k].x, y = q[k].y;</span><br><span class="line">                    <span class="keyword">if</span> (!cmp(y, a * x * x + b * x)) path[i][j] |= <span class="number">1</span> &lt;&lt; k;</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+<span class="number">1</span>&lt;<span class="number">1</span>&lt;&lt;n;i++){</span><br><span class="line">            <span class="keyword">int</span> x = lb[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++){</span><br><span class="line">                <span class="keyword">int</span> state = path[x][j];</span><br><span class="line">                f[i|state] = <span class="built_in">min</span>(f[i|state], f[i] +<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>

<img src="/downloads/imgs/itr-1000.png" class="example" width="500" height="500" title="title exg" alt="alt exg">
]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>方格取数</title>
    <url>/blog/%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0/</url>
    <content><![CDATA[<p>给你一个n∗n的格子的棋盘，每个格子里面有一个非负整数。<br>你需要从中取出若干个数，使得任意两个数所在的格子没有公共边，就是说所取的数所在的2个格子不能相邻，并且取出的数的和最大。</p>
<p>输入描述:</p>
<blockquote><p>每个测试实例包括一个整数n 和n∗n个非负整数，保证每个数不超过。</p>
</blockquote>

<a id="more"></a>

<p>示例1<br>输入</p>
<blockquote><p>3<br>75 15 21<br>75 15 28<br>34 70 5</p>
</blockquote>

<p>输出</p>
<blockquote><p>188</p>
</blockquote>

<p>说明</p>
<blockquote><p>n&lt;=16，每个数不超过 10^3。</p>
</blockquote>

<figure class="highlight c"><figcaption><span>fanggequshu.cpp</span><a href="/downloads/code/fanggequshu.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> mp[N][N], dp[N][<span class="number">70000</span>];</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">30005</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> res =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = n;</span><br><span class="line">    <span class="keyword">while</span>(y){</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>) res += mp[x][j];</span><br><span class="line">        j--; y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;mp[i][j]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);i++){</span><br><span class="line">        <span class="keyword">if</span>((i&amp;(i&gt;&gt;<span class="number">1</span>))==<span class="number">0</span>) A[++tot] = i;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    dp[i][k] = max(dp[i][k], dp[i-1][j] + val(i-1, j))</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=tot;k++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=tot;j++){</span><br><span class="line">                <span class="keyword">if</span>((A[j] &amp; A[k]) ==<span class="number">0</span>){</span><br><span class="line">                    <span class="keyword">int</span> val = calc(i, A[k]);</span><br><span class="line">                    dp[i][k] = <span class="built_in">max</span>(dp[i][k], dp[i<span class="number">-1</span>][j] + val);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++) ans = <span class="built_in">max</span>(ans, dp[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>chunji_nowcoder</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>树网的核 (NOIP2007)</title>
    <url>/blog/%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8/</url>
    <content><![CDATA[<p>设T=(V, E, W) 是一个无圈且连通的无向图（也称为无根树），每条边带有正整数的权，我们称T为树网（treenetwork），其中V, E分别表示结点与边的集合，W表示各边长度的集合，并设T有n个结点。<br>路径：树网中任何两结点a,b都存在唯一的一条简单路径，用d(a,b)表示以a,b为端点的路径的长度，它是该路径上各边长度之和。我们称d(a,b)为a,b两结点间的距离。<br>一点v到一条路径P的距离为该点与P上的最近的结点的距离：<br>d(v，P) = min{d(v，u)，u为路径P上的结点}。<br>树网的直径：树网中最长的路径称为树网的直径。对于给定的树网T，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。<br>偏心距ECC(F)：树网T中距路径F最远的结点到路径F的距离，即ECC(F)=min{d(v,F)，v∈V}。<br>任务：对于给定的树网T=(V, E,W)和非负整数s，求一个路径F，它是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过s（可以等于s），使偏心距ECC(F)最小。我们称这个路径为树网T=(V,E,W)的核（Core）。必要时，F可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。<br>下面的图给出了树网的一个实例。图中，A-B与A-C是两条直径，长度均为20。点W是树网的中心，EF边的长度为5。如果指定s=11，则树网的核为路径DEFG（也可以取为路径DEF），偏心距为8。如果指定s=0（或s=1、s=2），则树网的核为结点F，偏心距为12。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>第1行，两个正整数n和s，中间用一个空格隔开。其中n为树网结点的个数，s为树网的核的长度的上界。设结点编号依次为1, 2, …, n。<br>从第2行到第n行，每行给出3个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“2 4 7”表示连接结点2与4的边的长度为7。<br>所给的数据都是正确的，不必检验。</p>
</blockquote>

<p>输出描述:</p>
<blockquote><p>输出一个非负整数，为指定意义下的最小偏心距。</p>
</blockquote>

<p>示例1<br>输入</p>
<blockquote><p>5 2<br>1 2 5<br>2 3 2<br>2 4 4<br>2 5 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>示例2<br>输入</p>
<blockquote><p>8 6<br>1 3 2<br>2 3 2<br>3 4 6<br>4 5 3<br>4 6 4<br>4 7 2<br>7 8 3</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>备注：</p>
<blockquote><p>40%的数据满足：5 ≤ n ≤ 15<br>70%的数据满足：5 ≤ n ≤ 80<br>100%的数据满足：5 ≤ n ≤ 300, 0 ≤ s ≤ 1000。边长度为不超过1000的正整数</p>
</blockquote>

<figure class="highlight c"><figcaption><span>shuwangdehe.cpp</span><a href="/downloads/code/shuwangdehe.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>, M = N*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], idx, ne[M], w[M];</span><br><span class="line"><span class="keyword">int</span> q[N], st[N], dist[N];</span><br><span class="line"><span class="keyword">int</span> pre[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="built_in">vector</span>&lt;PII&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>{</span><br><span class="line">	e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> start)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> hh=<span class="number">0</span>, tt =<span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = start;</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	dist[start] = <span class="number">0</span>;</span><br><span class="line">	st[start] = <span class="literal">true</span>;</span><br><span class="line">	pre[start] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt){</span><br><span class="line">		<span class="keyword">int</span> u= q[hh++];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h[u]; ~i; i = ne[i]){</span><br><span class="line">			<span class="keyword">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span>(!st[j]){</span><br><span class="line">				st[j] = <span class="literal">true</span>;</span><br><span class="line">				dist[j] = dist[u] + w[i];</span><br><span class="line">				q[++tt] = j;</span><br><span class="line">				pre[j] = u;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">		<span class="keyword">if</span>(dist[i] &gt; dist[t])</span><br><span class="line">			t = i;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs_max</span><span class="params">(<span class="keyword">int</span> u)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> hh=<span class="number">0</span>, tt=<span class="number">0</span>;</span><br><span class="line">	dist[u] = <span class="number">0</span>;</span><br><span class="line">	q[<span class="number">0</span>] = u;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(hh&lt;=tt){</span><br><span class="line">		<span class="keyword">int</span> t= q[hh++];</span><br><span class="line">		res = <span class="built_in">max</span>(res, dist[t]);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=h[t];~i;i=ne[i]){</span><br><span class="line">			<span class="keyword">int</span> j = e[i];</span><br><span class="line">			<span class="keyword">if</span>(!st[j]){</span><br><span class="line">				st[j] = <span class="literal">true</span>;</span><br><span class="line">				dist[j] = dist[t] + w[i];</span><br><span class="line">				q[++tt] = j;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> mid)</span></span>{</span><br><span class="line">	<span class="keyword">int</span> u = <span class="number">0</span>, v = path.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(u+<span class="number">1</span>&lt;path.<span class="built_in">size</span>() &amp;&amp; path[u+<span class="number">1</span>].second &lt;= mid) u++;</span><br><span class="line">	<span class="keyword">while</span>(v<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; path.back().second - path[v<span class="number">-1</span>].second&lt;=mid) v--;</span><br><span class="line">	<span class="keyword">if</span>(u&gt;v) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>(path[v].second - path[u].second&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;path.<span class="built_in">size</span>();i++) st[path[i].first] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=u;i&lt;=v;i++)</span><br><span class="line">		<span class="keyword">if</span>(bfs_max(path[i].first) &gt; mid) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">	<span class="comment">// freopen("data.in", "r", stdin);</span></span><br><span class="line">	<span class="comment">// freopen("data.out", "w", stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++){</span><br><span class="line">		<span class="keyword">int</span> a, b, c;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		add(a, b, c), add(b, a, c);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	bfs(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> p = get_max();</span><br><span class="line">	bfs(p);</span><br><span class="line">	<span class="keyword">int</span> v = get_max();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(v!=<span class="number">-1</span>){</span><br><span class="line">		path.push_back(make_pair(v, dist[v]));</span><br><span class="line">		v = pre[v];</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	reverse(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">	<span class="comment">// for(int i=0;i&lt;path.size();i++)</span></span><br><span class="line">	<span class="comment">// 	printf("%d ", path[i].first);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r){</span><br><span class="line">		<span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(check(mid)) r = mid;</span><br><span class="line">		<span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, r);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title>机器翻译 (NOIP2010)</title>
    <url>/blog/%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91/</url>
    <content><![CDATA[<p>小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。</p>
<p>这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。</p>
<p>假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M−1，软件会将新单词存入一个未使用的内存单元；若内存中已存入M 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。</p>
<p>假设一篇英语文章的长度为N 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。</p>
<a id="more"></a>

<p>输入描述:</p>
<blockquote><p>输入共2 行。每行中两个数之间用一个空格隔开。<br>第一行为两个正整数M 和N，代表内存容量和文章的长度。<br>第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。</p>
</blockquote>


<p>输出描述:</p>
<blockquote><p>共1 行，包含一个整数，为软件需要查词典的次数。</p>
</blockquote>

<p>示例1<br>输入</p>
<blockquote><p>3 7<br>1 2 1 5 4 4 1</p>
</blockquote>

<p>输出</p>
<blockquote><p>5</p>
</blockquote>

<p>说明</p>
<blockquote><p>整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：<br>空：内存初始状态为空。<br>1． 1：查找单词1 并调入内存。<br>2． 1 2：查找单词2 并调入内存。<br>3． 1 2：在内存中找到单词1。<br>4． 1 2 5：查找单词5 并调入内存。<br>5． 2 5 4：查找单词4 并调入内存替代单词1。<br>6． 2 5 4：在内存中找到单词4。<br>7． 5 4 1：查找单词1 并调入内存替代单词2。<br>共计查了5次词典。</p>
</blockquote>

<p>备注：</p>
<blockquote><p>对于10%的数据有M=1，N ≤5。<br>对于100%的数据有0</p>
</blockquote>


<figure class="highlight c"><figcaption><span>jiqifanyi.cpp</span><a href="/downloads/code/jiqifanyi.cpp">view raw</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (!st[x])</span><br><span class="line">        {</span><br><span class="line">            res++;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() == m)</span><br><span class="line">            {</span><br><span class="line">                st[q.front()] = <span class="literal">false</span>;</span><br><span class="line">                q.pop();</span><br><span class="line">            }</span><br><span class="line">            q.push(x);</span><br><span class="line">            st[x] = <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>simulation</tag>
      </tags>
  </entry>
</search>
